#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author 1188755597 "usuario" 
\end_header

\begin_body

\begin_layout Chapter
Trabajos Relacionados
\begin_inset CommandInset label
LatexCommand label
name "chap:Trabajos-Relacionados"

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1188755597 1487110454
El enfoque propuesto básicamente es un proceso de aprendizaje de máquina
 que incluye una herramienta para recolectar mediciones de performance en
 Android (y Java), y otra herramienta para entrenar y evaluar modelos de
 predicción con diferentes técnicas de aprendizaje automático.
 Por lo tanto, este capítulo se dividirá en dos secciones para describir
 en la sección 3.1 un conjunto de herramientas sobre benchmarks en Android
 y en la sección 3.2 se presentarán algunos trabajos ya realizados que llevan
 a cabo la predicción de atributos a través de modelos.
\change_unchanged

\end_layout

\begin_layout Section
Herramientas de benchmarks para Android
\begin_inset CommandInset label
LatexCommand label
name "sec:Herramientas-de-benchmarks-para-Android"

\end_inset


\end_layout

\begin_layout Standard
Las herramientas de benchmarking han ido incrementando su popularidad ya
 que ofrecen a los usuarios la posibilidad de analizar a fondo todos los
 aspectos de un dispositivo android arrojando datos numéricos acerca de
 la potencia, eficiencia y capacidad de los mismos.
 La recolección y conocimiento de estas propiedades no funcionales son relevante
s y necesarios al momento de determinar cuál dispositivo será el más adecuado
 para satisfacer la carga de trabajo esperada.
 A continuación se describen algunas herramientas de benchmarking.
 
\end_layout

\begin_layout Subsection
Performance Monitors de Android 
\begin_inset CommandInset label
LatexCommand label
name "sub:Performance-Monitors-de-Android "

\end_inset


\end_layout

\begin_layout Standard
Es una herramienta integrada en el ambiente de desarrollo “Android Studio”
 y cuenta con varias sub herramientas que proveen información en tiempo
 real sobre la aplicación, estos datos capturados se almacenan en archivos
 para luego analizarlos en diferentes vistas.
 ‘Android Monitor’ utiliza la Máquina Virtual (VM) del dispositivo o emulador
 dependiendo de la versión del sistema Android, tal como se detalla en el
 siguiente cuadro
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Versión Android
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API(nivel)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 (e inferior)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dalvik VM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dalvik por defecto - ART VM opcional
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21 (y superior)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ART VM
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
En base a las vistas ofrecidas por la herramienta que deseen utilizarse
 y a determinadas características que maneje la aplicación, se deben configurar
 las propiedades requeridas para su uso descritas en el cuadro 3.2.
 Se pueden realizar pruebas de rendimiento sobre dispositivos Android conectados
 directamente a la aplicación o simulados a través de un emulador, en ambos
 casos se debe tener en cuenta que ´Android Device Monitor’ no puede ser
 utilizada.
 ADM es una herramienta standalone que permite depurar y analizar la aplicación
 sin necesidad de instalaciones en ambientes de desarrollo integrados.
 
\end_layout

\begin_layout Subsubsection*
Propiedades que se pueden medir
\end_layout

\begin_layout Itemize
LogCat monitor: Cuando la aplicación emite una excepción, se muestra un
 mensaje en esta vista junto con el detalle del seguimiento de la pila y
 un enlace al código asociado.
 Esta característica es útil para detectar y eliminar errores y mejorar
 el funcionamiento de la aplicación.
 
\end_layout

\begin_layout Itemize
Memory Monitor: permite visualizar gráficamente la memoria disponible y
 ocupada a lo largo del tiempo, los eventos realizados de garbage collection
 (GC), comprobar si los puntos de latencia de la aplicación se deben a un
 uso excesivo de garbage collection o si los puntos donde la aplicación
 deja de funcionar se debe a falta de memoria disponible.
 
\end_layout

\begin_layout Itemize
CPU Monitor: permite controlar fácilmente el uso de la CPU de la aplicación.
 Se muestra el uso de la CPU en tiempo real y muestra el porcentaje de tiempo
 de CPU total (incluyendo todos los núcleos) que se utiliza en el modo de
 usuario y el kernel.
 En el modo de usuario, el código debe utilizar las API del sistema para
 el acceso al hardware o a la memoria teniendo acceso sólo a la memoria
 virtual.
 En este modo, si la aplicación se detiene, es posible recuperarla.
 En el modo kernel, el código puede acceder directamente al hardware, incluyendo
 direcciones de memoria física y si por algún motivo la aplicación deja
 de funcionar, el dispositivo se detiene.
 
\end_layout

\begin_layout Itemize
GPU Monitor: brinda una representación visual rápida acerca del tiempo que
 requiere formar cada frame de la interfaz gráfica, en otras palabras, permite
 visualizar la cantidad de tiempo que le lleva al thread preparar, procesar
 y ejecutar los comandos gráficos.
 Esta vista provee una idea general sobre la performance de la interfaz,
 identificando procesos de renderizado excesivos en el tiempo y si estos
 picos en el proceso de renderización del frame son causados en torno al
 usuario o a acciones del programa.
 
\end_layout

\begin_layout Itemize
Network Monitor: permite realizar un seguimiento de cada solicitud de red
 que es realizada, al mismo tiempo que permite controlar la manera y el
 momento en que se llevan a cabo las transferencias de datos en la aplicación
 para optimizar el código subyacente de manera apropiada.
 Mediante el control de la frecuencia de las transferencias de datos, y
 la cantidad de datos transferidos durante cada conexión, se pueden identificar
 áreas de la aplicación que se podrían implementar de manera más eficiente
 y así, requerir menos energía de la batería.
 Generalmente, el propósito es detectar picos cortos que podrían ser demorados
 o que podrían retrasar la transferencia.
 Adicionalmente, la herramienta´Android Monitor´provee funciones para examinar
 información relevante sobre el estado de los servicios del sistema, y permite
 realizar capturas y videos de la pantalla.
\end_layout

\begin_layout Subsection
Benchit
\begin_inset CommandInset label
LatexCommand label
name "sub:Benchit"

\end_inset


\end_layout

\begin_layout Standard
“Benchit” es una librería Open Source implementada en lenguaje Java de Benchmark
ing para Android.
 El uso de esta herramienta se hace mediante un repositorio maven llamado
 JitPack (accedido a través de la URL "https://jitpack.io") el cual contiene
 el proyecto ‘T-Spoon/Benchit’.
 JitPack puede utilizarse tanto en proyectos Android como en la Máquina
 Virtual de Java y provee artefactos listos para su uso como archivos jar
 y aar.
 El proyecto ha ido configurado bajo las características expuestas a continuació
n:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Propiedad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Versión
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compile SDK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Build Tools
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.0.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min SDK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target SDK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Propiedades que se pueden medir
\end_layout

\begin_layout Standard
Benchit es un framework rápido y sencillo ya que permite añadir benchmarks
 en áreas de código deseadas para determinar el tiempo o latencia de la
 operación.
 
\end_layout

\begin_layout Standard
Una forma sencilla de utilizar esta librería es a través de iteraciones
 sobre una misma sección de código delimitadas entre las llamadas ‘Benchit.begin(
String tag)’ y ‘Benchit.end(String tag).log()’.
 De esta forma, con cada iteración, la herramienta va almacenando el tiempo
 de ejecución del código (diferencia entre el tiempo de comienzo y tiempo
 de fin).
 Al término de las iteraciones, mediante la llamada ´Benchit.analyze(String
 tag).log()’ se podrá observar el resultado en la herramienta LogCat.
 El resultado muestra tres propiedades: promedio, rango y desviación standard
 en el siguiente formato: 
\end_layout

\begin_layout Standard
D/Benchit﹕[benchmark-name] --> Sample Size[10], Average[22ms], Range[20ms
 --> 33ms], Deviation[4ms] 
\end_layout

\begin_layout Standard
La herramienta, también provee la posibilidad de realizar comparaciones
 entre todos o algunos benchmarks del código mostrando los resultados en
 el LogCat de manera ordenada.
 El orden de los resultados lo determina el usuario en base a la propiedad
 y tipo de orden (ascendente o descendente) que prefiera.
 Esta opción es útil, por ejemplo, al momento de comparar el desempeño de
 varios algoritmos o sentencias que realicen la misma acción de forma diferente.
\end_layout

\begin_layout Subsection
Google Caliper 
\begin_inset CommandInset label
LatexCommand label
name "sub:Google-caliper"

\end_inset


\end_layout

\begin_layout Standard
Google Caliper es un framework open source para implementar, ejecutar y
 visualizar resultados de microbenchmarks en aplicaciones Java, aunque brinda
 soporte para proyectos android accediendo a través de la rama de la versión
 0.5 ya que la rama 1.0 no funciona correctamente en android.
 Existen dos alternativas de acceso al proyecto a través del repositorio
 maven o el repositorio git.
 La integración del proyecto Caliper se logra añadiendo dos archivos del
 tipo JAR como dependencias, “allocation.jar” y “caliper-0.0.jar”.
 
\end_layout

\begin_layout Subsubsection*
Propiedades que se pueden medir
\end_layout

\begin_layout Standard
Caliper permite obtener diferentes medidas del código Java, principalmente
 microbenchmarks, pero también tiene soporte para otros tipos de medidas
 incluyendo memoria disponible, ocupada, u otras medidas arbitrarias de
 dominio específico como por ejemplo el radio de compresión.
 
\end_layout

\begin_layout Subsection
Java Microbenchmark Harness
\begin_inset CommandInset label
LatexCommand label
name "sub:Java-Microbenchmark-Harness"

\end_inset


\end_layout

\begin_layout Standard
Java Microbenchmark Harness o simplemente JMH, es una herramienta que facilita
 la implementación de benchmarks en forma correcta.
 El término correcto hace alusión a las optimizaciones que tanto la máquina
 virtual como el hardware subyacente aplican sobre el código durante la
 ejecución de los benchmarks y que no se aplican en sistemas de producción
 real, infiriendo en conclusiones erróneas sobre el rendimiento.
 JMH fue diseñada por los mismos desarrolladores de la máquina virtual de
 Java posibilitando la construcción, ejecución y análisis de benchmarks
 no sólo escritos en lenguaje Java sino en otros lenguajes soportados por
 la máquina virtual.
 El acceso a la herramienta se realiza a través del repositorio Maven, generando
 un nuevo proyecto JMH a partir del proyecto modelo.
 El proyecto generado contendrá una clase llamada ´MyBenchmark.java´ que
 funciona como template para implementar benchmarks directamente en ella
 o crear nuevas clases a partir de la generada.
\end_layout

\begin_layout Subsubsection*
Propiedades que se pueden medir
\end_layout

\begin_layout Standard
La librería JMH ofrece cinco tipos de medidas sobre el código.
 Estos atributos o modos como se denominan en la herramienta se especifican
 por medio de anotaciones Java en el encabezado del método principal de
 la clase “MyBenchmark” llamado “testMethod()”.
 A modo de ejemplo, la siguiente anotación define la medida elegida “Throughput”
: @BenchmarkMode(Mode.Throughput).
 Las propiedades provistas por la herramienta son detalladas a continuación:
 
\end_layout

\begin_layout Itemize
“Throughput”: mide el número de operaciones por segundo, en otras palabras,
 un estimativo sobre la cantidad de veces por segundo que el componente
 al que se le aplicó un benchmark podría ser ejecutado.
 
\end_layout

\begin_layout Itemize
“Average time”: mide el tiempo promedio que el componente requiere para
 ejecutarse.
 
\end_layout

\begin_layout Itemize
“Sample time”: mide el tiempo efectivo que el componente requirió en ejecutarse,
 incluyendo tiempo máximo y mínimo.
 
\end_layout

\begin_layout Itemize
“Single Shot”: mide el tiempo de ejecución de un simple método benchmark.
 “All”: computa y retorna todas las mediciones anteriores.
\end_layout

\begin_layout Subsection
JMeter
\begin_inset CommandInset label
LatexCommand label
name "sub:JMeter"

\end_inset


\end_layout

\begin_layout Standard
JMeter es una herramienta Open Source diseñada por Apache e implementada
 completamente en lenguaje Java para realizar pruebas de carga y medidas
 de rendimiento.
 En un principio, fue diseñada para realizar pruebas de rendimiento sobre
 aplicaciones Web pero luego ha sido extendida a otras funciones para cubrir
 diferentes categorías de testing, tal es el caso de los análisis de carga,
 de funcionalidad, desempeño, regresión, entre otros.
 JMeter es una aplicación de escritorio con una interfaz gráfica amigable
 para el usuario.
 Puede ser ejecutada bajo cualquier entorno o estación que acepte la máquina
 virtual de Java como es el caso de los sistemas operativos Windows, Linux
 y Mac.
 A grandes rasgos, la herramienta simula un grupo de usuarios que envían
 peticiones a un servidor y retorna un conjunto de estadísticas sobre el
 desempeño y funcionalidad por medio de gráficos, tablas, etc.
 El proyecto se instala fácilmente a partir de la siguiente URL: “http://jmeter.a
pache.org/download_jmeter.cgi”.
 Al tratarse de un framework basado en java, el único requerimiento es la
 instalación de la herramienta JDK a partir de la versión 6.
 
\end_layout

\begin_layout Subsubsection*
Propiedades que se puede medir
\end_layout

\begin_layout Standard
Apache JMeter puede realizar pruebas tanto en recursos estáticos como dinámicos.
 Se puede utilizar para simular un gran volumen de carga en un servidor
 o grupo de servidores y en la red y probar su resistencia o analizar el
 rendimiento general bajo diferentes tipos de carga.
 Los recursos que pueden evaluarse podrían ser servicios web (SOAP/ REST),
 lenguajes web dinámicos (PHP - Java - ASP.NET, archivos), base de datos
 vía JDBC y consultas a la base, conexiones generales bajo los protocolos
 FTP, LDAP, JMS, HTTP, HTTPS, TCP, protocolos de mensajerías como SMTP,
 POP3, IMAP y comandos y scripts de shell.
 
\end_layout

\begin_layout Section
Predicción de propiedades no funcionales con aprendizaje de máquina
\end_layout

\begin_layout Standard
La predicción de propiedades no funcionales ha contribuido a los arquitectos
 de software en la evaluación de sus sistemas durante la etapa de diseño,
 y guiar las decisiones respecto a los componentes que deben integrarse
 a la arquitectura del sistema de acuerdo a los requerimientos de calidad
 esperados.
 Diferentes trabajos han recurrido al uso de técnicas de aprendizaje de
 máquina para construir modelos de predicción de performance y otros atributos
 de calidad dinámicos.
 Hutter, Xu y Hoos [16] se han referido a estos modelos como modelos empíricos
 de performance (EPM por sus siglas en inglés) ya que requieren la recolección
 de mediciones empíricas sobre los componentes.
 La principal aplicación de estos modelos probablemente es el problema de
 selección de algoritmos, introducido en 1976 por John R.
 Rice [17].
 Este problema consiste en seleccionar el algoritmo, o configuración de
 algoritmo, de un portafolio de alternativas que minimice el tiempo de respuesta
, según la instancia de datos de entrada.
 La predicción del tiempo de respuesta ha sido abordada con éxito usando
 técnicas de aprendizaje supervisado, principalmente de regresión [16].
 En estos trabajos, los datos empíricos de entrenamiento son obtenidos en
 contextos de ejecución controlados, para enfocarse en la correlación entre
 la propiedad a predecir y las propiedades de los parámetros de entrada
 del componente o algoritmo.
 Una limitación de estos modelos es que no generalizan la predicción de
 las propiedades de performance al contexto de ejecución, es decir, no considera
n características del dispositivo y el ambiente de ejecución que influyen
 sobre el desempeño del componente, como su capacidad de cómputo y la disponibil
idad de recursos.
 
\end_layout

\begin_layout Standard
Este capítulo describe trabajos que inducen al desarrollo de una herramienta
 capaz de generalizar cualquier característica propia del componente de
 ejecución como así también del entorno donde se ejecuta para la aplicación
 de la técnica de aprendizaje de máquina que resulte la más adecuada para
 la predicción.
 Está organizado de la siguiente manera: la sección 3.2.1 presenta tres estudios
 sobre algoritmos de optimización que abarcan la predicción de otro de los
 indicadores más importantes, como lo es la precisión y en la sección 3.2.2
 presenta dos estudios de propiedades dinámicas sobre Servicios Web.
 
\end_layout

\begin_layout Subsection
Predicción de precisión sobre algoritmos de optimización.
 
\end_layout

\begin_layout Standard
Los modelos de predicción no sólo se utilizan para estimar el tiempo de
 respuesta del desempeño de los componentes, sino también para estimar otras
 propiedades.
 Mark Roberts, Adele Howe y Landon Flom [18] han construido dos modelos
 para la predicción del tiempo de respuesta y para la probabilidad de éxito
 de diferentes algoritmos de planeamiento utilizando técnicas de aprendizaje
 de máquina incluidas en la librería Weka.
 Para el aprendizaje fueron utilizados 4726 benchmarks, problemas o instancias
 para ejecutarse sobre 28 algoritmos de planeamiento conocidos.
 Por cada algoritmo y cada problema se registra si un plan fue encontrado
 (éxito) a través de los valores verdadero o falso y se registra el tiempo
 (en segundos) requerido en completar la ejecución.
 Ya que cada algoritmo define su propia forma en que un resultado es exitoso
 o no, de forma automática obtienen las métricas de precisión porcentuales
 sobre la salida.
 
\end_layout

\begin_layout Standard
Otros autores (Mersmann; Bischl; Trautmann; Wagner; Bossek y Neumann [19])
 predicen la optimalidad o razón de aproximación de algoritmos para el problema
 del viajante utilizando una técnica de regresión no lineal llamada MARS,
 por sus siglas en inglés.
 El modelo MARS se aplicó con éxito para predecir la calidad de aproximación
 del algoritmo de búsqueda local llamado 2-opt independiente del tamaño
 de la instancia sobre la base de las características de los casos generados
 con una precisión muy alta.
 Se cree firmemente que debiera ser sencillo aplicar la misma metodología
 a otros algoritmos y utilizar estos modelos para derivar una estrategia
 para el problema de selección de algoritmos en el contexto de los problemas
 TSP.
\end_layout

\begin_layout Standard
Finalmente, el trabajo desarrollado por los autores Beveridge, Givens, Phillips
 y Draper [20] se analiza la precisión de tres componentes diferentes para
 el reconocimiento de rostros en imágenes, utilizando una técnica de regresión
 lineal denominada GLMM, por Generalized Linear Mixed Models.
 
\end_layout

\begin_layout Subsection
Predicción sobre Servicios Web 
\end_layout

\begin_layout Standard
La predicción de propiedades dinámicas de servicios Web, como su tiempo
 de respuesta, throughput y probabilidad de fallos, es más compleja de abordar
 con respecto a componentes locales ya que depende del estado de la infraestruct
ura de red y el proveedor del servicio, que no se puede monitorear desde
 el dispositivo cliente.
 Un enfoque ingenioso para abordar este problema fue propuesto en [21].
 En este trabajo, los autores se basan en la premisa de que las propiedades
 de performance de los servicios Web varían respecto a características del
 contexto como la ubicación geográfica y el momento del día y la semana
 en el que se realiza una solicitud al servicio.
 De esta forma, recolectan la información del consumo de servicios de múltiples
 clientes alrededor del mundo para generalizar modelos de predicción.
 Este enfoque es conocido como predicción colaborativa ya que los datos
 empíricos de entrenamiento son brindados por múltiples nodos de manera
 distribuida.
 Los autores llevaron a cabo un experimento a gran escala que involucró
 más de 30 millones de invocaciones a servicios Web en más de 80 países,
 por usuarios distribuidos en más de 30 países.
 La observación experimental indica que diferentes usuarios pueden tener
 diferentes experiencias de uso sobre el mismo servicio, influenciados por
 la conexión de red y los ambientes heterogéneos entre usuarios y proveedores.
 Los datos se encuentran disponibles públicamente y han sido utilizados
 en varios trabajos para la construcción y comparación de modelos de performance
 con diferentes técnicas de aprendizaje de máquina [22][23].
 
\end_layout

\end_body
\end_document
