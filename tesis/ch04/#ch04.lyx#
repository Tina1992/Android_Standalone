#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Enfoque y Herramientas
\begin_inset CommandInset label
LatexCommand label
name "chap:Enfoque-y-Herramientas"

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se describe el enfoque propuesto para extraer información
 y conocimiento de un conjunto de características inherentes a componentes
 de software y propiedades estáticas y dinámicas del dispositivo android
 de ejecución para analizar las relaciones y dependencias y predecir atributos
 no funcionales en base a dichas propiedades.
 Para el diseño se hizo énfasis en la optimización combinada de los parámetros
 de los algoritmos de aprendizaje automático.
 
\end_layout

\begin_layout Standard
El enfoque plantea llevar a cabo la predicción de propiedades no-funcionales
 mediante un proceso de aprendizaje de máquina a través de 
\emph on
i
\emph default
) la recolección de indicadores o mediciones tomados a partir de la información
 provista de la ejecución de piezas de software, considerando atributos
 de componentes, atributos inherentes al problema de entrada, y atributos
 de la operación y resultados de la ejecución, y 
\emph on
ii
\emph default
) la construcción de modelos como un proceso interactivo con el usuario
 a partir de la configuración inicial de los datos, la optimización automática
 de los parámetros de acuerdo a las tasas de error arrojadas por métricas
 de evaluación y el ajuste final del modelo a través del análisis de las
 curvas de aprendizaje.
 
\end_layout

\begin_layout Standard
Como soporte para el enfoque, se desarrollaron dos herramientas independientes
 entre sí y diseñadas para efectuar el objetivo y conexión de las dos fases
 propuestas.
 Por un lado, se desarrolló una herramienta denominada 
\emph on
Android Performance Testing and Prediction
\emph default
 cuyo diseño se adapta fácilmente a la implementación de cualquier dominio
 computacional del que se quiera obtener indicadores de desempeño.
 Al tratarse de un framework implementado para el sistema Android, permite
 obtener de manera directa los benchmarks del dispositivo de interés para
 el análisis.
 Por otro lado, se desarrolló una herramienta standalone denominada 
\emph on
Nekonata
\emph default
 diseñada para brindar soporte al uso de las funciones de cualquier librería
 que realice aprendizaje automático y minería de datos escritas en lenguaje
 Java y que consiste en dos fases, una primer etapa para la construcción
 del modelo a partir del conjunto fuente de benchmarks mediante un proceso
 de automatización de los algoritmos en complemento de información gráfica
 para la colaboración interactiva del usuario y finalmente una segunda etapa
 de ajustes al modelo teniendo en cuenta los efectos de overfitting y underfitti
ng consecuentes del entrenamiento.
 
\end_layout

\begin_layout Standard
Estas cuestiones se describen en detalle de la siguiente manera.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Aplicaciones-de-la"

\end_inset

 se enumeran algunos de los usos prácticos de los modelos incluyendo aplicacione
s de la propuesta.
 Luego, en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Etapas-del-método"

\end_inset

 se profundiza sobre las distintas etapas del enfoque y flujo de trabajo.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Herramientas"

\end_inset

 se describen cada uno de los frameworks desarrollados, presentando la herramien
ta para la recolección de datos en la subsección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Framework-de-medición"

\end_inset

 y finalmente, en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Herramienta-de-entrenamiento"

\end_inset

 se presenta la herramienta para la construcción de modelos evaluativos.
 
\end_layout

\begin_layout Section
Aplicaciones de la propuesta 
\begin_inset CommandInset label
LatexCommand label
name "sec:Aplicaciones-de-la"

\end_inset


\end_layout

\begin_layout Standard
Los problemas de clase NP - Completos están presentes en la mayoría de ámbitos
 computacionales.
 Afortunadamente, en la medida que estos problemas resultan difíciles de
 resolver frente a los peores casos de entrada, se hace más factible resolverlos
 aún considerando problemas de grandes instancias.
 
\end_layout

\begin_layout Standard
Desafortunadamente, estos algoritmos pueden exhibir variaciones extremas
 de ejecución a través de las instancias con distribuciones reales, incluso,
 aunque la dimensión del problema se mantuviera constante, la misma instancia
 puede requerir dramáticamente diferentes tiempos de ejecución en función
 del algoritmo utilizado.
 Existe una escasa comprensión teórica de las causas de esta variación.
 Durante la última década, una cantidad considerable de trabajo ha intentado
 demostrar cómo utilizar las técnicas de aprendizaje automático supervisado
 para la construcción de modelos de regresión que proporcionen respuestas
 aproximadas a esta pregunta en base a los datos de rendimiento del algoritmo
 analizado, en otras palabras, podría creerse que es posible predecir el
 tiempo que requerirá un determinado algoritmo para ejecutarse bajo una
 entrada en particular construyendo un modelo de tiempo de ejecución del
 algoritmo como una función de las características específicas de cada instancia
 del problema.
 
\end_layout

\begin_layout Standard
La construcción de tales modelos conocidos como 
\emph on
modelos de actuación empírica 
\emph default
(EPM por sus siglas en inglés) ha ido creciendo y motivada debido a la utilidad
 que presentan frente a una gran variedad de contextos prácticos.
 A continuación, se detallan algunos:
\end_layout

\begin_layout Description
Selección
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

algoritmos Como se ha tratado en algunos trabajos 
\begin_inset CommandInset citation
LatexCommand citet
key "Hutter2014"

\end_inset

, los modelos de predicción son útiles para la selección automática de algoritmo
s y la configuración en una variedad de formas (un problema clásico de selección
 del mejor algoritmo entre un determinado conjunto); a través de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{EPM}
\end_layout

\end_inset

 se logra predecir el rendimiento de cada uno de estos algoritmos candidatos
 y mediante un análisis comparativo, seleccionar el más apropiado considerando
 la instancia del problema y las características del hardware.
 
\end_layout

\begin_layout Description
Ajustes
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

parámetros
\begin_inset space ~
\end_inset

y
\begin_inset space ~
\end_inset

configuración
\begin_inset space ~
\end_inset

automática
\begin_inset space ~
\end_inset

del
\begin_inset space ~
\end_inset

algoritmo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{EPM}
\end_layout

\end_inset

 sirve a dos propósitos fundamentales, por un lado, modelar el comportamiento
 o funcionalidad de un algoritmo parametrizado en base a la configuración
 de tales parámetros, en cuyo caso se puede alternar entre el aprendizaje
 del modelo y su uso para identificar configuraciones interesantes para
 evaluar posteriormente.
 Por otro lado, se puede modelar el rendimiento del algoritmo basado conjuntamen
te en las características de las instancias del problema y la configuración
 de sus parámetros.
 Tales modelos pueden utilizarse para ajustar los valores de tales parámetros
 y obtener una mejor predicción basada en la instancia particular.
 
\end_layout

\begin_layout Description
Generación
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

benchmarks
\begin_inset space ~
\end_inset

fuertes Un modelo predictivo para uno o más algoritmos se puede utilizar
 para establecer los parámetros de los generadores de benchmarks existentes
 con el fin de crear instancias asociadas al algoritmo particular.
 
\end_layout

\begin_layout Description
Obtener
\begin_inset space ~
\end_inset

una
\begin_inset space ~
\end_inset

visión
\begin_inset space ~
\end_inset

general
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

las
\begin_inset space ~
\end_inset

instancias
\begin_inset space ~
\end_inset

y
\begin_inset space ~
\end_inset

el
\begin_inset space ~
\end_inset

rendimiento
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

los
\begin_inset space ~
\end_inset

algoritmos 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{EPM}
\end_layout

\end_inset

 se puede utilizar para evaluar las características de la instancia y los
 valores de los parámetros del algoritmo que más impactan en el rendimiento.
 Algunos modelos son compatibles con este tipo de evaluaciones directamente.
 Para otros modelos, existen métodos de selección de atributos (características
 genéricas) para identificar un grupo más reducido de entradas del modelo
 que son claves, y describen el rendimiento del algoritmo casi tan bien
 como todo el conjunto de entradas.
 
\end_layout

\begin_layout Description
Selección
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

Servicio
\begin_inset space ~
\end_inset

y
\begin_inset space ~
\end_inset

composición Cuando varios servicios web implementan la misma funcionalidad,
 los modelos de rendimiento resultan ser un buen criterio para escoger el
 mejor candidato entre ellos.
 Incluso en tiempo de ejecución, los proveedores de servicio pueden cambiarse
 si las condiciones del contexto y los parámetros de entrada se modifican.
 
\end_layout

\begin_layout Description
Programación
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

tareas
\begin_inset space ~
\end_inset

en
\begin_inset space ~
\end_inset

redes
\begin_inset space ~
\end_inset

móviles Suponiendo un conjunto de tareas que deben asignarse entre un conjunto
 de dispositivos, los modelos de rendimiento podrían obtener una medida
 exacta del tiempo de respuesta que cada tarea requerirá sobre cada dispositivo
 con el fin de minimizar el tiempo total de secuenciación de las tareas.
 
\end_layout

\begin_layout Description
Otros.
 
\end_layout

\begin_layout Section
Etapas del método
\begin_inset CommandInset label
LatexCommand label
name "sec:Etapas-del-método"

\end_inset


\end_layout

\begin_layout Standard
El enfoque propuesto se conceptualiza como un proceso de tres fases complementar
ias.
 Este ciclo o flujo de trabajo da lugar a tres etapas bien definidas por
 cada dominio o escenario de estudio, desde la obtención de indicadores
 hasta la predicción de propiedades no funcionales en entornos de aplicación.
 La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:method-stages"

\end_inset

 muestra un esquema conceptual del enfoque, cuyas etapas se describen a
 continuación:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/method-stages.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema conceptual del enfoque en fases.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:method-stages"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Testing El proceso comienza con la creación de datasets.
 Cada dataset pertenece a un escenario o dominio diferente del cual se extraen
 todas las características que podrían influir sobre el desempeño del componente.
 Durante la ejecución de cada servicio o pieza de software se van realizando
 las mediciones o métricas sobre distintos aspectos de la operación y registrand
o cada uno de estos benchmarks en un archivo para su posterior análisis.
 
\end_layout

\begin_layout Description
Learning A partir del conjunto de benchmarks obtenidos, se aplican técnicas
 de aprendizaje de máquina para la extracción de conocimiento de estos datos
 y construir, consecuentemente, modelos predictivos que mejor se ajusten
 a la generalización de la información mediante un proceso de entrenamiento
 y evaluación de los mismos.
 
\end_layout

\begin_layout Description
Predict Finalmente, se pretende utilizar estos modelos de predicción en
 entornos de aplicación que permitan la selección del componente más adecuado
 en base a un conjunto de propiedades del problema de entrada, las propiedades
 internas del dispositivo en el cual se llevará a cabo la ejecución, y un
 conjunto de restricciones que deben satisfacerse, a través de un proceso
 automatizado que determine al usuario la opción más favorable evitando
 la ejecución de cada componente.
 
\end_layout

\begin_layout Section
Herramientas
\begin_inset CommandInset label
LatexCommand label
name "sec:Herramientas"

\end_inset


\end_layout

\begin_layout Standard
El trabajo presentado conforma dos de las tres fases propuestas para el
 enfoque global del desarrollo.
 La primer fase se lleva a cabo en un framework particular para la medición
 de propiedades de componentes Android que será detallada en la sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Framework-de-medición"

\end_inset

.
 La segunda fase para la construcción de modelos predictivos a través de
 técnicas de aprendizaje de máquina se desarrolla en una segunda herramienta
 la cual será detallada en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Herramienta-de-entrenamiento"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Framework de medición para Android
\begin_inset CommandInset label
LatexCommand label
name "sub:Framework-de-medición"

\end_inset


\end_layout

\begin_layout Subsubsection*
Enfoque general
\end_layout

\begin_layout Standard
“Android Performance Testing and Prediction” es un framework diseñado para
 realizar mediciones de performance de componentes ejecutados bajo el sistema
 Android.
 Es una herramienta de testing que permite “correr” diferentes piezas de
 software y evaluar propiedades influyentes y características del entorno
 de ejecución.
 
\end_layout

\begin_layout Standard
La herramienta cuenta con el soporte necesario para adaptarse a cualquier
 dominio informático y exportar las mediciones correspondientes en archivos
 de formato CSV, mediciones que servirán de fuente para herramientas de
 predicción a través de técnicas de aprendizaje de máquina.
 
\end_layout

\begin_layout Subsubsection*
Objetivos
\end_layout

\begin_layout Standard
El rendimiento de los componentes de ejecución (algoritmos, servicios Web,
 procesos ejecutándose en segundo plano, etc.) dependen de varios factores:
 “el contexto de ejecución” donde el componente está funcionando, los “parámetro
s de entrada” que requiere el componente de la operación, y su “implementación
 interna”.
 Sin embargo, al utilizar componentes de terceros, generalmente se desconoce
 su implementación actuando como "cajas negras" a los desarrolladores móviles,
 que sólo conocen sus interfaces de aplicaciones, pero no su trabajo interno.
 
\end_layout

\begin_layout Standard
Para elaborar un análisis del rendimiento, técnicas de aprendizaje automático
 sobre los datos recogidos empíricamente pueden ser utilizados para construir
 modelos de predicción del tiempo de ejecución del componente, como una
 función de los parámetros de entrada y las características específicas
 del contexto de ejecución: configuración de algoritmos, selección de servicios,
 planificación de trabajos, por citar algunos ejemplos.
 
\end_layout

\begin_layout Subsubsection*
Enfoque
\end_layout

\begin_layout Standard
El enfoque principal de esta herramienta está centrado en dos propiedades:
 el tiempo de respuesta y la precisión de los resultados.
 
\end_layout

\begin_layout Standard
El tiempo de respuesta refiere al tiempo total que demanda un componente
 en ejecutar una operación o tarea, es decir, el tiempo para responder a
 una solicitud con una entrada determinada.
 Por otro lado, la precisión es una medida que evalúa la calidad de los
 resultados o salida de un componente y tiene diferentes significados semánticos
 dependiendo de la funcionalidad requerida, por ejemplo, en problemas de
 clasificación, se toma el concepto de precisión como la medida estadística
 de la eficacia de un clasificador, la precisión está relacionada a la identific
ación o exclusión correctamente de una condición.
 En problemas de optimización, también conocido como optimalidad, la precisión
 es una relación entre la solución de salida obtenida y la solución óptima
 conocida.
 
\end_layout

\begin_layout Standard
Para construir un modelo de predicción del tiempo de respuesta sobre un
 componente particular, se deben considerar dos variables al momento de
 evaluar, un conjunto acerca de las características del contexto de ejecución
 (E,) por ejemplo, núcleos de CPU, tipo de red, etc.
 y otro conjunto acerca de las características de la entrada en particular
 (I), por ejemplo, en tamaño expresado en bytes.
 Por lo tanto, el modelo resulta una función R(c) que depende tanto de E
 como de I.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FUNCION
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Del mismo modo se construye un modelo de predicción de precisión sobre un
 componente, como en la mayoría de los casos esta medida no depende de las
 características del contexto en el que se ejecuta, el modelo respondería
 a una función como la siguiente:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FUNCION
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Componentes
\end_layout

\begin_layout Standard
El análisis de rendimiento que se propone en esta herramienta se basa en
 entidades de software individuales de ejecución que proveen servicios a
 través de una interfaz específica.
 De aquí en más, estas entidades se denotarán componentes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/android-component.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema conceptual de componentes Android considerados.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:android-component"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la figura 4.2 se pueden observar los tres tipos de componentes generalizados
 por la herramienta para obtener los resultados de mediciones adecuados,
 incluyendo servicios Web y servicios específicos de la plataforma Android,
 para toda pieza de software remanente los componentes son tratados simplemente
 como objetos Java.
 Las instancias de objetos hacen referencia a cualquier componente residente
 en el espacio de memoria de una aplicación, el componente específico para
 servicios web incluye cualquier componente remoto fuera del dispositivo
 y accedidos a través de protocolos de comunicación Web, como HTTP.
 Por último el componente específico para servicios Android incluye cualquier
 proceso ejecutado en segundo plano residente en el mismo dispositivo y
 accedidos a través de objetos Intent (como único mecanismo de comunicación
 entre procesos del sistema Android).
 
\end_layout

\begin_layout Subsubsection*
Diseño e implementación
\end_layout

\begin_layout Standard
El framework “Android-Performance-Testing-and-Prediction” está conformado
 por tres proyectos individuales.
 El proyecto “Android-Testing-Tool”constituye el modelo base para llevar
 a cabo el proceso de medición de propiedades de cualquier tipo de componente.
 En el cuadro 4.1 se detalla el conjunto de librerías requeridas para su
 funcionamiento.
 Los proyectos restantes han sido implementados para desarrollar diferentes
 dominios de aplicación, los cuales incluyen la dependencia al proyecto
 modelo.
 El proyecto “Evaluation-of-Face-Detection-Services” fue diseñado para obtener
 mediciones sobre servicios que ofrecen reconocimiento facial y el proyecto
 “Examples-Android-Testing-Tool” fue diseñado para dominios de problemas
 NP, incluyendo a problemas de la clase P y NP - Completos.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dependencias
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Librería
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Versión
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
android
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang english
android support
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
httpclient
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4.1.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang english
android async http
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.4.9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
google play services
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Configuración
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
min Sdk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
target Sdk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Dependencias requeridas por el proyecto Android-Testing-Tool.
\end_layout

\end_inset


\end_layout

\end_inset

A continuación serán descritos los principales factores que han servido
 de guía para el diseño del proyecto base “Android-Testing-Tool”.
 
\end_layout

\begin_layout Subsubsection*
Componentes
\end_layout

\begin_layout Standard
Como se detalla en la figura 4.3, la herramienta utiliza una representación
 simplificada de los componentes a través de la interfaz parametrizada´Component
´.
 Los parámetros que recibe son dos objetos del tipo Input y Output, siendo
 éstos, instancias de objetos que representan la entrada y salida del problema
 respectivamente.
 En caso de utilizar servicios Android o Servicios Web como componentes,
 además de implementar la interfaz ya mencionada debe extenderse su comportamien
to a las clases ‘AndroidServiceClient’ y ´WebServiceClient’ respectivamente.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/android-component-representation.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Representación de los objetos implementados como componentes Android.
\begin_inset CommandInset label
LatexCommand label
name "fig:android-component-representation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Operación
\end_layout

\begin_layout Standard
Cada uno de los componentes asociados a un problema específico ejecutan
 una operación o tarea a través de la llamada al método execute del componente.
 Esta operación es responsable de evaluar la ejecución de la instancia de
 entrada en el componente y retornar un objeto de salida o respuesta del
 problema.
 Tanto ´Input´ como ´Output´ son dos conceptos abstractos que representan
 instancias reales del problema.
 Una instancia de entrada puede encapsular no sólo los parámetros requeridos
 para realizar la ejecución del componente, sino la configuración de los
 mismos.
 Por otro lado, una instancia de salida encapsula la respuesta o resultado
 de esa operación.
\end_layout

\begin_layout Subsubsection*
Métricas
\end_layout

\begin_layout Standard
Como puede observarse en la figura 4.4 a nivel implementación, las métricas
 se representan a través de objetos cuyo comportamiento se define a través
 de la interfaz parametrizada que corresponda.
 La herramienta distingue cuatro tipos de métricas en función del elemento
 de medición, determinando el parámetro que recibe: 
\end_layout

\begin_layout Enumerate
Métricas globales sobre características estáticas del contexto: cualidades
 del entorno de ejecución que se mantienen estáticas (sin cambio) durante
 el plan de pruebas, por ejemplo, modelo del dispositivo, arquitectura de
 la CPU, cantidad de núcleos de CPU, tamaño de memoria, etc.
 Estos objetos deben implementar la interfaz Metric<Context>, siendo ´Context’
 la interfaz implementada por Android para acceder a la información global
 del entorno de la aplicación.
 
\end_layout

\begin_layout Enumerate
Métricas generales sobre características de la entrada: atributos inherentes
 al dominio del problema, por ejemplo, en el problema de detección de rostros
 algunas características podrían ser el nombre de imagen, tamaño o contraste,
 formato de archivo, etc.
 Estos objetos deben implementar la interfaz Metric<Input>, siendo Input,
 una instancia de entrada real del dominio.
 
\end_layout

\begin_layout Enumerate
Métricas generales del componente: propiedades del componente como el nombre,
 su ubicación, etc.
 Estos objetos deben implementar la interfaz Metric<Component<Input, Output>>.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/android-metrics-representation.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Representación de los objetos implementados como Métricas.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:android-metrics-representation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
4.
 Métricas de operación: Son medidas que actúan sobre la ejecución del componente
, por lo cual distinguen en tres tipos diferentes: 
\end_layout

\begin_layout Itemize
Características de la salida: características del resultado de la operación
 como su tamaño, calidad, etc.
 al igual que las entidades de entrada, son inherentes al dominio del problema.
 En la detección de rostros, por ejemplo, la salida podría ser un vector
 con la ubicación de los puntos detectados y una característica de salida
 interesante podría ser, el tamaño de ese vector, es decir, el número de
 rostros detectados.
 
\end_layout

\begin_layout Itemize
Características dinámicas del contexto: características del entorno de ejecución
 que pueden variar de una operación a otra, como el uso de CPU, el número
 de procesos en ejecución, tipo de conexión, ubicación del dispositivo,
 etc.
 
\end_layout

\begin_layout Itemize
Características de desempeño: medidas de interés sobre el rendimiento que
 varían de una operación a otra, como el tiempo de respuesta, el consumo
 de batería, operaciones ejecutadas con éxito o con error, etc.
\end_layout

\begin_layout Standard
Estos objetos deben implementar la interfaz OperationMetric<Input, Output>
 como se muestra en la figura 4.5.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/android-metrics-components-representation.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Representación de las métricas que actúan sobre la ejecución del componente.
\begin_inset CommandInset label
LatexCommand label
name "fig:android-metrics-components-representation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Ejecuciones de planes de prueba
\end_layout

\begin_layout Standard
La forma de organizar diferentes modelos de evaluación se realiza a través
 de la creación de planes de prueba, que se configuran y posteriormente
 se ejecutan para obtener un archivo de formato CSV con el resultado de
 todas las mediciones incorporadas al plan de pruebas.
 
\end_layout

\begin_layout Standard
La herramienta implementa por defecto un objeto llamado “TestPlan” que define
 una ejecución sistemática de las operaciones y métricas sobre ellos.
 Básicamente, un modelo de plan de pruebas se compone de un conjunto posible
 de componentes, un conjunto posible de objetos de entrada, y un conjunto
 posible de métricas para realizar las mediciones, dando la posibilidad
 de configurar estas propiedades a los requerimientos deseados.
 
\end_layout

\begin_layout Subsubsection*
Resultados
\end_layout

\begin_layout Standard
Una vez configurado el plan de pruebas, su ejecución se lleva a cabo mediante
 el objeto Executor definido por la herramienta.
 Los resultados con las mediciones son almacenados en otro objeto denominado
 ´Results’ y los datos son exportados a un archivo de formato CSV para su
 posterior procesamiento.
 Estos archivos son guardados en un subdirectorio del proyecto correspondiente
 bajo el nombre “results”.
\end_layout

\begin_layout Subsubsection*
Evaluación de servicios remotos
\end_layout

\begin_layout Standard
El objetivo de la incorporación de dominios que implican el uso de servicios
 remotos se basa en la idea de automatizar el testeo continuo de uno o varios
 servicios, en este caso, aplicaciones que ofrecen reconocimiento facial,
 teniendo en cuenta las características que estos pueden proveer y aquellas
 que el usuario de la aplicación desee considerar, de esta manera determinar
 el servicio más adecuado (según el contexto) para la ejecución de una tarea.
 Este dominio ha sido diseñado a través de un proyecto individual bajo el
 nombre de “Evaluation-of-Faces-Detection-Services”.
 Este proyecto se implementó como un modelo básico y genérico sobre el proceso
 de detección de rostros.
 Tal proyecto conforma una estructura general para almacenar y acceder a
 todos los atributos posibles que cualquier servicio que brinde la funcionalidad
 de detección de rostros pudiera ofrecer.
 
\end_layout

\begin_layout Standard
A continuación se describirá la forma en que los principales objetos involucrado
s en el diseño general de la herramienta fueron usados en este proyecto,
 junto con un módulo adicional para el registro de información.
 
\end_layout

\begin_layout Paragraph*
Módulo para el registro de características faciales:
\end_layout

\begin_layout Standard
El objeto principal de este módulo del proyecto es brindar la posibilidad
 de almacenar todos los datos que el servicio de detección facial ofrezca,
 a pesar que éste no provea algunas de las propiedades contempladas.
 Para cumplir con tal propósito se diseñaron los siguientes objetos para
 cubrir las necesidades referentes a las características faciales
\end_layout

\begin_layout Description
FacePosition: Almacenamiento de las posiciones respecto a la imagen de los
 rostros detectados.
 
\end_layout

\begin_layout Description
FaceRace: Es un objeto del tipo Enumerado para contemplar los diferentes
 colores de tez.
 
\end_layout

\begin_layout Description
FaceExpression: Almacenamiento de todas las expresiones faciales de un rostro
 detectado en particular a través de su nombre y un valor de confianza asociado.
 
\end_layout

\begin_layout Description
FaceOrientation: Este objeto contempla cuatro posibles orientaciones de
 un rostro: frontal, perfil derecho, perfil izquierdo y desconocido en el
 caso que la orientación facial no haya podido ser definida.
 También, considera tres tipos de ángulos de giro del rostro conocidos por
 su nombre en inglés como: ‘yaw’, ‘roll’ y ‘pitch’.
 
\end_layout

\begin_layout Description
FaceLandmark: Este objeto contempla cada uno de los posibles puntos faciales
 de interés para detectar conocidos por su nombre en inglés como “landmarks”,
 ojos, nariz, boca, mejillas, cejas, por citar algunos ejemplos, almacenando
 su nombre identificatorio y sus coordenadas X e Y donde se encuentran en
 la imagen.
 
\end_layout

\begin_layout Standard
A través del objeto definido como “FaceImpl” se logra centralizar toda informaci
ón asociada a la detección de un rostro en particular.
 El comportamiento de este objeto está definido a través de la interfaz
 implementada bajo el nombre “Face”.
 “FaceImpl” incluye en su lista de atributos un objeto del tipo FacePosition,
 FaceRace,y FaceOrientation, y un conjunto de objetos del tipo FaceExpression
 y FaceLandmark.
 Además de estas propiedades, añade nuevos datos de interés sobre el rostro
 detectado: probabilidad de ojos abiertos, probabilidad de sonrisa, género
 y cantidad de años estimados.
 
\end_layout

\begin_layout Paragraph*
Componentes
\end_layout

\begin_layout Standard
Se evaluará y analizará la performance de cada uno de los servicios implementado
s, en base a los parámetros de configuración que acepta cada uno de estos
 servicios, se generan diferentes instancias de componentes posibles.
 
\end_layout

\begin_layout Paragraph*
Instancias de entrada
\end_layout

\begin_layout Standard
Respecto a las entradas del problema, el sistema a través de la clase “InputFace
Detection” recibe un archivo como parámetro correspondiente a una imagen
 para ser procesada.
 Adicionalmente a la clase ya mencionada, se diseñó una nueva clase llamada
 “FDDB_DataSetUtils” la cual permite crear una lista de imágenes de entrada
 a partir de un archivo de formato de texto.
 
\end_layout

\begin_layout Standard
La clase acepta dos tipos de archivos: uno simple conteniendo una lista
 con todos los nombres de las imágenes localizadas en el mismo directorio
 del archivo, y otro archivo más completo, conteniendo además del nombre
 de la imagen, la cantidad total de rostros presentes y por cada uno de
 ellos, una línea adicional conteniendo cinco puntos faciales de posición:
 major_axis_radius, minor_axis_radius, angle, center_x, center_y.
 Estos puntos son almacenados en objetos del tipo “FacePosition” y a través
 de la imagen y una lista con los objetos recién mencionados se crea la
 instancia de entrada correspondiente.
 
\end_layout

\begin_layout Standard
Por lo tanto, las entradas pueden ser añadidas al plan de pruebas a través
 de archivos o de manera estática especificando la ruta de cada imagen.
 
\end_layout

\begin_layout Paragraph*
Instancias de salida
\end_layout

\begin_layout Standard
En el caso de los servicios remotos, la respuesta obtenida debe ser previamente
 parseada antes de poder almacenar la información.
 En el caso de los servicios locales, sólo deben ser ejecutados.
 Los resultados, es decir, el conjunto de todos los rostros detectados y
 su información asociada, se registra mediante el objeto “FaceDetectionResultImp
l” cuyo comportamiento está definido por la interfaz “FaceDetectionResult”.
 
\end_layout

\begin_layout Paragraph*
Métricas
\end_layout

\begin_layout Standard
A continuación se detallan todas las métricas consideradas en este dominio
 bajo el ámbito que operan: 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Proceso Implementan 
\emph on
OperationMetric<InputFaceDetection, FaceDetectionResult>
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
CorrectDetectedFacesMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
DetectedFacesMetrics.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ResponseTimeMetric.java
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Entrada Implementan Metric<InputFaceDetection>
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageContrastMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageEntropyMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageFormatMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageMeanIntensityMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageNumberOfFacesMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageNumberOfPixelsMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ImageSizeMetric.java 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
InputNameMetric.java 
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Componente
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
ComponentNameMetric.java
\end_layout

\end_deeper
\begin_layout Paragraph*
Plan de ejecución
\end_layout

\begin_layout Standard
El plan de pruebas diseñado para este dominio es un objeto llamado “TestPlanFace
Detection”.
 
\end_layout

\begin_layout Subsubsection*
Dominios y Servicios implementados
\end_layout

\begin_layout Standard
El framework de medición ha sido diseñado para soportar distintos dominios
 sobre los cuáles tomar las medidas deseadas.
 Por el momento sólo implementa dos tipos de dominios: por un lado, problemas
 clásicos del tipo NP para el análisis del desempeño de diferentes algoritmos
 de resolución y por otro lado, aplicaciones de propósito general, en este
 caso, aplicaciones que ofrecen reconocimiento facial para la evaluación
 de diferentes servicios que ofrecen esta misma funcionalidad, como ya ha
 sido anticipado.
 
\end_layout

\begin_layout Standard
Los problemas de complejidad NP se contemplan bajo un proyecto individual
 llamado “Examples-Android-Testing-Tool” para la evaluación de desempeño
 de distintos algoritmos considerando dos aspectos fundamentales: tiempo
 (aproximación del número de pasos de ejecución que emplea el algoritmo)
 y espacio (aproximación de la cantidad de memoria utilizada).
 Los problemas implementados pertenecen tanto a la clase P como a la clase
 NP-Completos.
 
\end_layout

\begin_layout Standard
Respecto a la implementación de servicios, se han utilizado servicios tanto
 remotos como locales por medio de librerías de dependencia.
 
\end_layout

\begin_layout Standard
Todos los dominios implementados serán descritos en las subsecciones siguientes.
 
\end_layout

\begin_layout Subsection*
Problema del agente viajero
\end_layout

\begin_layout Standard
En el campo de la teoría de complejidad computacional, el problema del viajante
 o TSP por sus siglas en inglés, es tratado como un problema NP-Completo
 y es modelado como un grafo de manera que las ciudades son sus vértices,
 los caminos son las aristas y las distancias entre caminos son los pesos
 de las aristas.
 Es un problema de minimización tras la búsqueda de un recorrido completo
 que comienza y finaliza en un vértice específico y visita el resto de los
 vértices exactamente una vez con coste mínimo.
 Existen muchas variantes del problema, una de ellas se trata del TSP simétrico
 en el cual la distancia entre un par de ciudades es la misma en cada dirección
 formando un grafo ponderado no dirigido.
 Esta variante fue la versión considerada por la herramienta.
 
\end_layout

\begin_layout Subsubsection*
Instancias de entrada
\end_layout

\begin_layout Standard
Con el fin de garantizar instancias variadas del problema, (diferentes cantidade
s de ciudades, distintas representaciones y pesos), se incorporó a la herramient
a una librería llamada TSPLib con múltiples archivos de instancias del problema.
 La librería cuenta con 111 archivos de formato TSP, y 32 archivos de formato
 OPT.TOUR que contienen el recorrido óptimo del archivo que referencian.
 Los ejemplos oscilan desde 14 y hasta 18512 ciudades con un sólo ejemplo
 extremo de 85900, y utilizan cuatro funciones de cálculo de la distancia
 entre ciudades: distancia euclidiana, distancia geométrica, distancia pseudo
 euclidiana y función techo.
 
\end_layout

\begin_layout Standard
Para la obtención de las mediciones correspondientes, se realizó una preselecció
n de 32 archivos que comprenden ejemplos de entre 22 y 200 ciudades.
 Cabe destacar que fue necesaria la implementación de un parser para el
 uso de los archivos cuyo nombre es ParserDataSetTPSLIB.
 Complementariamente, se implementó una clase llamada ‘TSPInstance’ para
 generar instancias arbitrarias del problema a partir de dos atributos:
 cantidad total de ciudades y ciudad inicial.
 A través del método ‘generateRandom’ la matriz de costos se genera a través
 del método ‘Random’ de la clase ‘Math’ modelando un grafo ponderado no
 dirigido.
 Por otro lado, es posible la generación de instancias específicas seteando
 directamente el atributo correspondiente a la matriz de costos 
\end_layout

\begin_layout Subsubsection*
Instancias de salida
\end_layout

\begin_layout Standard
Tras la ejecución de los componentes, los resultados son almacenados en
 la clase definida ‘TSPSolution’, la cual contiene una lista con todas las
 aristas incluidas en la solución y brinda métodos específicos para la obtención
 de esta lista y el costo total del recorrido
\end_layout

\begin_layout Subsubsection*
Diseño de plan de pruebas
\end_layout

\begin_layout Standard
Para la modelación del problema del viajante se plantearon siete componentes,
 cada uno desarrollando un algoritmo de resolución diferente.
 Las métricas incorporadas al plan pertenecen a tres de los cuatro tipos
 brindados por la herramienta: respecto a la entrada, sólo se consideró
 el nombre asociado a la matriz de costos, o del archivo de la librería
 TSPLIB según corresponda, respecto a los componentes, se consideró el nombre
 del algoritmo y respecto a la operación de ejecución de cada algoritmo,
 se incluyeron al plan las siguientes características del resultado: precisión,
 exactitud, valor del costo resultante y recorrido total.
 En la figura 4.6 se muestra un esquema del plan de pruebas planteado cuyo
 nombre es “TSPTestPlan”.
 
\end_layout

\begin_layout Standard
Los algoritmos de resolución planteados son descritos exhaustivamente en
 el apéndice A.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/TSP-TestPlan.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modelo del plan de pruebas para el dominio TSP.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:TSP-TestPlan"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Problema de la mochila
\end_layout

\begin_layout Standard
Al igual que el problema del agente viajero, el problema de la mochila o
 ‘Knapsack problem’ por su nombre en inglés, es un problema NP-Completo
 de optimización combinatoria, es decir, se busca la mejor solución entre
 un conjunto finito de posibles soluciones al problema.
 El problema simula la colocación de ítems u objetos en una mochila de tal
 forma que se maximice el valor de los ítems que contiene con la restricción
 de no superar el peso (o volumen) máximo que puede soportar la mochila.
\end_layout

\begin_layout Subsubsection*
Instancias de entrada
\end_layout

\begin_layout Standard
Se implementó una clase llamada ‘KnapsackInstance’ para generar instancias
 arbitrarias del problema a través del método ‘generateRandom’.
 Este método necesita de cuatro valores: cantidad total de ítems, máximo
 valor y peso de un ítem, y finalmente el peso o capacidad de la mochila.
 En base a estos parámetros se genera una instancia con tres atributos fundament
ales: una lista con todos los valores de los ítems, una lista con los pesos
 de cada ítem y la capacidad de la mochila (valor entre 0.0 y 1.0).
 La generación de estas instancias se realiza de manera estática desde el
 plan de pruebas.
 
\end_layout

\begin_layout Subsubsection*
Instancias de salida
\end_layout

\begin_layout Standard
Para registrar los resultados, se definió una clase denominada ‘KnapsackSolution
’, la cual, a partir de la ejecución de cada componente, va almacenando
 los ítems seleccionados para la solución.
 A través de esta clase se tiene acceso, además del conjunto solución, a
 la suma total de todos los ítems incorporados a la mochila y a la suma
 total de sus pesos.
 
\end_layout

\begin_layout Subsubsection*
Diseño de plan de pruebas
\end_layout

\begin_layout Standard
Para la modelación del problema de la mochila se plantearon sólo dos componentes
, uno corresponde al desarrollo del algoritmo Greedy y el otro al desarrollo
 de la técnica de backtracking para la resolución del problema.
 
\end_layout

\begin_layout Standard
Las métricas incorporadas al plan pertenecen a tres de los cuatro tipos
 brindados por la herramienta: respecto a la entrada se consideró incorporar
 como datos la cantidad de ítems y la capacidad de la mochila, respecto
 a los componentes sólo se considera el nombre del mismo y respecto a la
 operación de ejecución de cada componente se incluyó el valor solución,
 es decir, la suma total de los ítems incorporados en la mochila y el tiempo
 de respuesta.
 
\end_layout

\begin_layout Standard
En la figura 4.7 se muestra un esquema del plan de pruebas planteado cuyo
 nombre es ‘TestPlanKnapsackProblem’.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/Knapsack-TestPlan.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modelo del plan de pruebas para el problema de la mochila.
\begin_inset CommandInset label
LatexCommand label
name "fig:Knapsack-TestPlan"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Multiplicación de matrices
\end_layout

\begin_layout Standard
El producto de matrices corresponde a problemas de clase P ya que a diferencia
 de los problemas NP, su complejidad es polinómica.
\end_layout

\begin_layout Standard
El producto entre matrices no es conmutativo, depende del orden de las matrices
 intervinientes y su multiplicación sólo es posible si el número de filas
 de la primer matriz es igual al número de columnas de la segunda.
 
\end_layout

\begin_layout Subsubsection*
Instancias de entrada
\end_layout

\begin_layout Standard
Se diseñó el objeto “MatrixPair”, que como indica su nombre permite la creación
 de instancias con dos matrices cuyos valores se pueden originar de manera
 aleatoria a partir del número de filas y columnas de la primer matriz denominad
a matriz A y el número de columnas de la segunda matriz denominada matriz
 B, esta distinción es importante teniendo en cuenta la propiedad de no
 conmutatividad del producto de matrices.
 Por otro lado, ambas matrices pueden ser configuradas externamente y seteadas
 directamente a una instancia “MatrixPair”.
 
\end_layout

\begin_layout Subsubsection*
Instancias de salida
\end_layout

\begin_layout Standard
En el diseño de este problema no se implementó un objeto específico para
 almacenar resultados, ya que sólo se trata de otra matriz, producto del
 resultado de la multiplicación.
 Por lo tanto, se toma como instancia de salida al tipo de matriz implementada
 por el lenguaje Java cuyos valores son del tipo primitivo ‘double’.
 
\end_layout

\begin_layout Subsubsection*
Diseño de plan de pruebas
\end_layout

\begin_layout Standard
Para la modelación del problema de la multiplicación de matrices se plantearon
 sólo dos componentes, el objeto “MatrixMultiplication” que realiza los
 cómputos en un sólo thread , y el objeto “MatrixMultiplicationMultiThread”
 que distribuye el proceso de multiplicación en ocho threads.
 Las métricas incorporadas al plan son las siguientes: respecto a la entrada
 se considera el número de columnas y filas de la primer matriz y el número
 de columnas de la segunda.
 Respecto a los componentes sólo se considera el nombre del mismo y respecto
 a la ejecución se incluyó la memoria en uso, la memoria disponible y el
 tiempo de respuesta.
 
\end_layout

\begin_layout Subsection*
Servicios web 
\end_layout

\begin_layout Standard
Para la modelación de servicios remotos, en el proyecto “Evaluation-of-Face-Dete
ction-Services” se consideraron sólo dos servicios: ‘SkyBiometry’ y ‘FaceRect’.
 Tales servicios web son consumidos directamente desde la aplicación online
 ‘Mashape’, la cual ofrece una gran variedad de aplicaciones, incluida una
 colección de Aplicaciones sobre detección y reconocimiento de rostros.
 SkyBiometry y FaceRect son aplicaciones que utilizan interfaz REST, es
 decir, los métodos son llamados a través de internet usando los métodos
 HTTP standard como GET y POST a las direcciones correspondientes.
 Dependiendo de los parámetros especificados en el request, el servidor
 puede generar la respuesta tanto en formato JSON como XML.
 Adicionalmente, se utilizó el servicio GMS Visión de Google a partir de
 la librería correspondiente.
 Los tres servicios son descritos en detalle en el apéndice B.
 
\end_layout

\begin_layout Subsection*
FaceRect
\end_layout

\begin_layout Subsubsection*
Detalle del servicio
\end_layout

\begin_layout Standard
A continuación, se puede observar todos los servicios provistos por esta
 aplicación: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/FaceRect-servicies.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Servicios ofrecidos por la aplicación FaceRect.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:FaceRect-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Opcionalmente, se puede incorporar al proceso de detección tres puntos faciales:
 nariz, ojos y boca englobados bajo el nombre de “features”.
 Por defecto esta opción no se considera a menos que el usuario lo especifique
 en la creación del servicio.
\end_layout

\begin_layout Subsubsection*
Detalle de implementación
\end_layout

\begin_layout Standard
El servicio se implementó a través de la clase ‘FaceRect’ cuyo único atributo
 ‘features’ permite seleccionar o no la detección de los puntos faciales.
 Esta opción es seteada al momento de creación de una instancia dando paso
 a dos tipos de componentes, un componente sería el servicio FaceRect básico
 y el otro el servicio FaceRect con los puntos faciales o ‘features’ incluidos.
\end_layout

\begin_layout Subsection*
SkyBiometry
\end_layout

\begin_layout Subsubsection*
Detalle de servicio
\end_layout

\begin_layout Standard
Esta aplicación, en comparacion de ‘FaceRect’ mencionada anteriormente,
 es más completa en cuanto a las características que puede detectar.
 
\end_layout

\begin_layout Standard
El servicio permite también, la selección del tipo de detector entre dos
 opciones: un detector del estilo “normal” (valor por defecto) y un detector
 del estilo “agresivo”, en comparación más lento aunque más preciso en la
 calidad de sus respuestas.
 
\end_layout

\begin_layout Standard
A continuación, se puede observar algunos de los servicios provistos por
 esta aplicación, quizás los servicios significativamente más importantes:
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/SkyBiometry-services.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Servicios más significativos ofrecidos por la aplicación SkyBiometry.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:SkyBiometry-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Opcionalmente, se puede incorporar al proceso de detección los atributos
 detallados en la imagen siguiente: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/SkyBiometry-optional-services.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Atributos opcionales de la aplicación SkyBiometry.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:SkyBiometry-optional-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Detalle de implementación
\end_layout

\begin_layout Standard
El servicio fue implementado a través de la clase ‘SkyBiometry’ la cual
 contiene sólo tres atributos de carácter opcional ofrecido por la aplicación:
 ‘gender’, ‘glasses’ y ‘smiling’ y un cuarto atributo para referenciar el
 tipo de detector.
 Estas opciones son seteadas al momento de creación de una instancia dando
 paso a dieciséis tipos de componentes, es decir, el servicio con cada combinaci
ón posible de los atributos configurables.
 
\end_layout

\begin_layout Subsection*
GMSFaceAPI
\end_layout

\begin_layout Standard
La compañía Google ha implementado una colección extensa y variada de aplicacion
es para Android.
 Entre ellas, ofrece el paquete ‘com.google.android.gms.vision’ el cual proporciona
 una funcionalidad común para trabajar con detectores de objetos visuales.
 En la imagen 4.8 se muestra la forma en que el objeto ‘GoogleAPIClient’
 proporciona una interfaz para conectar y hacer llamadas a cualquiera de
 los servicios de Google Play disponibles tales como ‘Google Play Games’,
 ‘Google Drive’, ‘Google Maps’, etc
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/GooglePlay-services.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema conceptual para el uso de servicios de Google Play Services.
\begin_inset CommandInset label
LatexCommand label
name "fig:GooglePlay-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Servicios ofrecidos
\end_layout

\begin_layout Standard
El detector puede computar los siguientes atributos (accesibles a través
 de los distintos métodos de la clase).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/GooglePlay-services-options.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Servicios propios del detector de la aplicación GMS.
\begin_inset CommandInset label
LatexCommand label
name "fig:GooglePlay-services-options"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Respecto a las propiedades que pueden configurarse en el detector, se detalla:
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/GooglePlay-services-attributes.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Atributos configurables de la aplicación GMS.
\begin_inset CommandInset label
LatexCommand label
name "fig:GooglePlay-services-attributes"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/GooglePlay-services-classifiers.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Clasificadores ofrecidos por la aplicación GMS.
\begin_inset CommandInset label
LatexCommand label
name "fig:GooglePlay-services-classifiers"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Detalle de implementación
\end_layout

\begin_layout Standard
El servicio se implementó a través de una clase llamada ‘GMSFaceAPI’ la
 cual contiene sólo tres atributos configurables para el servicio: ‘allLandmarks
’, ‘allClassifications’ y ‘accurateMode’.
 Estas opciones son seteadas al momento de creación de una instancia dando
 paso a ocho tipos de componentes, es decir, el servicio con cada combinación
 posible de los atributos opcionales.
 Cabe destacar que el uso de este servicio sólo es posible por medio de
 la incorporación de la librería de google play services al proyecto “Evaluation
-of-Face-Detection-Services”.
 
\end_layout

\begin_layout Subsection
Herramienta de entrenamiento y evaluación de modelos
\begin_inset CommandInset label
LatexCommand label
name "sub:Herramienta-de-entrenamiento"

\end_inset


\end_layout

\begin_layout Standard
El eje que ha guiado el diseño de la herramienta ha sido el brindar soporte
 para el uso de cualquier librería que ofrezca aprendizaje de máquina a
 través de la implementación de todos los conceptos involucrados como objetos
 independientes a los cuales adaptar las funcionalidades de las librerías.
 La herramienta 
\emph on
Nekonata
\emph default
 lleva a cabo dos tipos de procesos en el desarrollo de sus funciones, procesos
 automatizados y procesos que requieren la colaboración del usuario con
 el fin de mejorar los resultados a partir de vistas gráficas sobre el comportam
iento y características de los modelos y además, para incluir en el proceso
 el interés y criterio del usuario.
 
\end_layout

\begin_layout Standard
El enfoque y objetivo de la herramienta se concluyen en dos etapas, una
 fase de entrenamiento de modelos y una fase de evaluación y mejora de los
 mismos.
 
\end_layout

\begin_layout Standard
En la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:prediction-tool"

\end_inset

 se muestran las vistas iniciales de la herramienta , presentación y configuraci
ón de datos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/prediction-tool.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Captura de pantalla de la herramienta: (A) Presentación, (B) Configuración
 de datos, (C) Menú de selección de opciones.
\begin_inset CommandInset label
LatexCommand label
name "fig:prediction-tool"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Entrenamiento de modelos
\end_layout

\begin_layout Standard
En esta sección se brindará un enfoque global y expresarán las consideraciones
 de los conceptos relacionados al proceso de entrenamiento.
 Posteriormente, se describe en detalle el flujo de desarrollo del proceso.
 Estos conceptos han sido el eje del diseño de la herramienta.
 A continuación, se presenta un listado de los objetos tratados: 
\end_layout

\begin_layout Subsubsection*
Librerias
\end_layout

\begin_layout Standard
Al día de hoy se han implementado bibliotecas que realizan aprendizaje automátic
o en múltiples lenguajes de programación.
 A pesar de la gran variación que existe entre unos y otros, el uso de técnicas
 de aprendizaje de máquina se rige bajo los mismos conceptos: durante la
 etapa de entrenamiento, un conjunto de datos que servirán como base de
 datos del proceso y una lista de algoritmos categorizados según realicen
 una función de regresión o clasificación (distinción que lleva a cada bibliotec
a definir los tipos de atributos numéricos y categóricos), finalmente durante
 la etapa de evaluación, es necesario el uso de métricas o indicadores matemátic
os para evaluar la calidad del clasificador.
 Estos principios permiten generalizar el término 
\emph on
librería
\emph default
 independizando la implementación específica de cada biblioteca añadida
 al sistema.
 
\end_layout

\begin_layout Standard
La herramienta Nekonata utiliza la biblioteca Weka, una plataforma de software
 para el aprendizaje automático y la minería de datos escrito en Java y
 desarrollado en la Universidad de Waikato y popularmente conocida ya que
 contiene una extensa colección de técnicas para preprocesamiento de datos
 y modelado.
 
\end_layout

\begin_layout Subsubsection*
Base de datos
\end_layout

\begin_layout Standard
Los archivos dataset usados para el entrenamiento, a menudo son vistos como
 una grilla de valores cuyas columnas representan cada una de las característica
s del dominio comúnmente denominadas clases o atributos y cuyas filas denominada
s instancias representan cada uno de los ejemplos del escenario de estudio.
 Bajo estas consideraciones, a nivel conceptual existe un objeto único como
 dataset que obtiene los datos a través de un proceso de parseo del archivo
 fuente a los objetos correspondientes de la librería utilizada, generalizando
 toda funcionalidad requerida mediante el acceso a la representación de
 los atributos e instancias.
 
\end_layout

\begin_layout Subsubsection*
Instancias
\end_layout

\begin_layout Standard
Tal como se adelantó anteriormente, cada dataset está formado por un conjunto
 de ejemplos tomados de un dominio en particular.
 Cada ejemplo constituye una instancia individual del problema representada
 por un conjunto de dos valores, el nombre del atributo y su respectivo
 indicador.
\end_layout

\begin_layout Subsubsection*
Modelos
\end_layout

\begin_layout Standard
La herramienta Nekonata está orientada al aprendizaje supervisado de predicción
 mediante funciones de regresión e incluye la técnica adaptada de agrupamiento
 a través de cluster como alternativa.
 Ambos casos fueron diseñados para incorporar los algoritmos que se deseen
 asegurando el correcto uso de sus funciones.
\end_layout

\begin_layout Subsubsection*
Parámetros
\end_layout

\begin_layout Standard
Los algoritmos de aprendizaje automático se rigen bajo fórmulas matemáticas
 que a menudo incluyen constantes o coeficientes cuyo valor incide directamente
 en la calidad y desempeño del clasificador.
 Algunos algoritmos no tienen parámetros adicionales más que los atributos
 del dominio, otros en cambio, tienen parámetros simples o complejos.
 Un parámetro simple es aquel conformado por un único valor y un parámetro
 complejo aquel constituido por una serie de valores, en la mayoría de casos
 se trata de algoritmos internos del algoritmo principal, tal es el caso
 de la función Kernel que utilizan los algoritmos de vectores de soporte.
 
\end_layout

\begin_layout Subsubsection*
Optimización
\end_layout

\begin_layout Standard
Los algoritmos pueden aplicarse utilizando los valores por defecto de los
 parámetros sin embargo pueden variarse conjuntamente para adaptarse mejor
 a los datos de entrenamiento y producir modelos predictivos más adecuados.
 Un proceso de optimización define rangos de valores válidos para cada uno
 de los parámetros admitidos y ejecuta a través de un proceso evaluativo,
 la combinación cruzada de cada opción, evaluando cada alternativa posible.
 Como resultado, se obtiene la mejor de todas las configuraciones para el
 algoritmo en cuestión.
\end_layout

\begin_layout Standard
La herramienta Nekonata considera la optimización de algoritmos de regresión,
 clusterers y funciones kernel.
 
\end_layout

\begin_layout Standard
Las consideraciones mencionadas anteriormente son el punto de partida en
 el mecanismo de aprendizaje.
 El proceso de entrenamiento de modelos (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:prediction-workflow"

\end_inset

) básicamente lleva a cabo la configuración de todos los datos requeridos
 para ejecutar los algoritmos clasificadores y obtener, posteriormente los
 modelos.
 Estos datos están directamente afectados por la biblioteca de aprendizaje
 automático que se use por lo que se dispondrá de diferentes opciones de
 selección variando entre una librería y otra.
 Esta disposición dio lugar a un flujo determinado en el orden de las actividade
s.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/prediction-workflow.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de flujo del proceso de entrenamiento de modelos.
\begin_inset CommandInset label
LatexCommand label
name "fig:prediction-workflow"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La selección de la librería de aprendizaje automático es el punto de partida
 condicionando el resto de los datos configurables.
 Luego, al seleccionar el archivo fuente con los benchmarks medidos en formato
 CSV, a través de un proceso de parseo se obtiene el archivo comúnmente
 llamado dataset adaptado al formato de instancias de la librería.
 Con este nuevo formato se extraen los atributos para seleccionar aquel
 que se pretenda predecir y junto con la selección de algoritmos se inicia
 la optimización de los mismos.
 
\end_layout

\begin_layout Standard
Los algoritmos de aprendizaje se habilitan al momento de elegir la librería
 a utilizar ofreciendo sólo aquellos que la librería dispone.
 La multi selección de clasificadores brinda la posibilidad al usuario de
 elegir los algoritmos de mayor preferencia o interés para optimizar en
 ese momento evitando el proceso de optimización de todos los clasificadores
 lo cual significaría un ahorro en el uso de los recursos computacionales.
 
\end_layout

\begin_layout Standard
Finalmente, como resultado de esta etapa se obtiene el conjunto de clasificadore
s seleccionados cuyas configuraciones son las más favorables para los datos
 de entrenamiento 
\end_layout

\begin_layout Subsubsection
Evaluación de modelos
\end_layout

\begin_layout Standard
En esta sección se detallarán las consideraciones y los enfoques generales
 del proceso de evaluación y métricas de error.
 También, se especificará el flujo de las actividades llevadas a cabo para
 calificar el desempeño del clasificador y realizar ajustes de ser necesario.
 
\end_layout

\begin_layout Subsubsection*
Evaluación
\end_layout

\begin_layout Standard
El dataset de origen, también denominado conjunto de datos de aprendizaje
 o entrenamiento, es utilizado para obtener el modelo predictivo que generalice
 esos datos adecuadamente.
 El término generalizar hace referencia a obtener una función que se ajuste
 a los datos en cuanto minimice el 
\emph on
error empírico
\emph default
 que es el error producido por el algoritmo.
 Se asume que los datos de entrenamiento constituyen una muestra lo suficienteme
nte representativa para aplicar un clasificador.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
OJO AHORA SABEMOS QUE NO ES ASI
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
El proceso de evaluación, entonces, debe utilizar nuevos datos de entrada
 (preferentemente distintos al conjunto de entrenamiento) y predecir la
 salida a partir de éstos arrojando ciertamente una tasa de error en la
 predicción hecha por el clasificador.
 Existen dos métodos clásicos de evaluación en base al origen de los datos
 usados para la validación de modelos.
 El más sencillo resulta de utilizar los mismos datos que fueron usados
 para la fase de entrenamiento.
 El método restante conocido bajo el nombre de validación cruzada (‘Cross
 validation’ por su nombre en inglés) tiene una metodología más compleja.
 
\end_layout

\begin_layout Standard
El método de validación cruzada utiliza un coeficiente 
\emph on
K
\emph default
 de repetición y división; los datos de entrada se dividen en 
\emph on
K
\emph default
 subconjuntos, utilizando uno de ellos como dato de prueba y el resto (
\emph on
K-1
\emph default
) como datos de entrenamiento.
 El proceso es repetido durante 
\emph on
K
\emph default
 iteraciones, con cada uno de los posibles subconjunto de datos de prueba.
 Finalmente se calcula la media aritmética de los resultados de cada iteración
 para obtener un único resultado.
 Los resultados de la evaluación son contemplan mediante un conjunto de
 indicadores que se describirán más adelante.
 Nekonata implementa ambos métodos e incluye la funcionalidad necesaria
 para acceder a todos los valores predictivos.
 
\end_layout

\begin_layout Subsubsection*
Métricas
\end_layout

\begin_layout Standard
Las métricas usadas para la evaluación de los algoritmos simplemente son
 fórmulas matemáticas o composición de ellas que involucran únicamente a
 dos variables, los valores reales del dominio y los valores predictivos.
 En la herramienta se ha implementado el conjunto de indicadores más popular
 brindando, conjuntamente, la posibilidad de utilizar las métricas ofrecidas
 por cada biblioteca incorporada.
 También, se han definido e incorporado cuatro características globales
 asociadas a las métricas para brindar soporte a otras funcionalidades.
 Toda métrica 
\emph on
i
\emph default
) brinda algún tipo de información, acerca del error de predicción o estadística
s o atributos de los datos; 
\emph on
ii
\emph default
) tiene una representación particular de los indicadores, los valores pueden
 estar normalizados en una escala del 0 al 1, expresados en porcentajes
 o simplemente adaptados a la escala de los datos; 
\emph on
iii
\emph default
) definen por su naturaleza un requerimiento minimo o maximo de su indicador
 y 
\emph on
iv
\emph default
) son aplicables a un tipo de función ya sea regresión o clasificación.
 
\end_layout

\begin_layout Standard
Con el fin de extremar las mejoras y asegurar que el modelo resultante sea
 el más favorable para el conjunto de datos usados en el entrenamiento el
 proceso de evaluación de modelos fue dividido en dos fases.
 Luego de la etapa de entrenamiento, los algoritmos clasificadores optimizados
 son expuestos a una serie de métricas dispuestos de manera tal que permita
 visualizar las diferencias de desempeño entre clasificadores con la misma
 métrica considerada.
 Esta vista es un recurso ofrecido al usuario para decidir aquel modelo
 que a su criterio tenga mejor calidad a través de la comparación simultánea
 y continuar mejorando el modelo elegido a partir del análisis de los efectos
 de underfit y overfit.
 
\end_layout

\begin_layout Subsubsection*
Fase 1: Comparación de modelos
\end_layout

\begin_layout Standard
La optimización de un algoritmo clasificador para obtener la configuración
 más apropiada para el conjunto de datos es conveniente,sin embargo, resulta
 más útil aplicar un proceso de optimización a un conjunto de algoritmos
 candidatos para luego analizar cuál de ellos es el que mejor generaliza
 los datos.
 La comparación entre clasificadores se realiza por medio de métricas que
 arrojan una estimación acerca del error de predicción, es decir, una medida
 que refleja la diferencia entre los datos reales del dominio y los valores
 predichos por el algoritmo.
 Es conveniente trasladar el análisis a la mayor cantidad de métricas posibles,
 ya que un mismo indicador podría arrojar valores cercanos entre un algoritmo
 y otro favoreciendo equivocadamente a uno de ellos, error que podría notarse
 al compararlos simultáneamente con otras métricas.
 La metodología de operación de esta fase se muestra en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:models-comparison-workflow"

\end_inset

.
 
\end_layout

\begin_layout Standard
Nekonata hace foco en este detalle y ofrece al usuario una vista de imágenes
 con los indicadores medidos de cada algoritmo seleccionado por el usuario
 para aplicar el proceso de optimización y elegir, posteriormente, el que
 resulte más adecuado.
 La información gráfica complementaria que se brinda, detalla los algoritmos
 representados por medio de barras y agrupados en categorías separadas de
 acuerdo a cada métrica a modo de facilitar la comparación.
 Adicionalmente las barras se colorean en dos tonos diferentes para acentuar,
 por cada métrica, los clasificadores que significarían las mejores opciones
 para ese indicador.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/models-comparison-workflow.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de flujo de la fase de comparación de modelos.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:models-comparison-workflow"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La disposición de todas las métricas de evaluación se han distribuido en
 imágenes dispares para agruparlas según la clase de información que representan
, ya sean indicadores del error de predicción o características sobre los
 datos.
 En el primer caso también se distinguen entre aquellas métricas interpretadas
 a valores normalizados entre cero y uno y métricas a valores de escala
 del atributo.
 De esta forma se agrupan en conjuntos los indicadores proclives a compararse
 mutuamente como puede observarse en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:screenshot-errors"

\end_inset

.
 
\end_layout

\begin_layout Standard
El aporte del usuario se incorporó para personificar el interés y criterio
 para determinar los indicadores más significativos para basar la elección
 del modelo más favorable.
 De esta manera, cada usuario puede basar su elección analizando y comparando
 los indicadores que a su criterio son más relevantes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/screenshot-errors.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Captura de pantalla de la vista de indicadores sobre el error de predicción
 normalizados.
\begin_inset CommandInset label
LatexCommand label
name "fig:screenshot-errors"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Fase 2: Ajustes al modelo
\end_layout

\begin_layout Standard
A través del uso de métricas se adquiere una idea estimativa del desempeño
 del clasificador frente al conjunto de datos de entrenamiento, sin embargo,
 podría resultar útil conocer el comportamiento general del algoritmo, contrasta
ndo cada uno de los valores reales del atributo clase con los valores predichos
 por el clasificador, y obtener así una vista exacta de la manera en que
 el clasificador se ajusta a los datos (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:screenshot-error-curve"

\end_inset

).
 
\end_layout

\begin_layout Standard
Este recurso es usado en la herramienta como un gráfico de dos líneas continuas
 de distinto color para representar el conjunto de datos de entrenamiento
 y el conjunto de datos predichos.
 Cada punto del dominio corresponde a cada instancia y la unión entre puntos
 sólo se realiza con fines ilustrativos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/screenshot-error-curve.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Captura de pantalla de la vista del error de predicción.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:screenshot-error-curve"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El análisis del error de predicción es la base para comprender la calidad
 del modelo construido hasta el momento aunque no es el único objetivo,
 ya que la vista permite extraer conocimiento de cómo se comporta el conjunto
 de datos de entrenamiento, existencia de valores extremos, la variación
 de los valores tomados, entre otros.
 Es un recurso gráfico para complementar la información que se le brinda
 al usuario y encaminarlo a un correcto proceso de ajuste del modelo.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/adjustment-workflow.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de flujo de la fase de ajuste.
\begin_inset CommandInset label
LatexCommand label
name "fig:adjustment-workflow"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El flujo de desarrollo de esta fase se planteó como un proceso de carácter
 opcional e iterativo para el usuario.
 Se puede optar simplemente por almacenar el modelo elegido durante la etapa
 de comparación anterior o repetir las veces que se desee un procedimiento
 de análisis de las curvas de aprendizaje del modelo y las acciones consecuentes
 para reparar los posibles efectos, como se muestra en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:adjustment-workflow"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Esto esta implementado pero no en el standalone, habria que dejarlo?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación se explicará el funcionamiento de la fase brindando una visión
 general del planteamiento de las curvas de aprendizaje con las respectivas
 consideraciones que se tuvieron en cuenta y la manera en que se ha incluido
 la participación del usuario para la transformación del conjunto de datos.
 
\end_layout

\begin_layout Paragraph*
Curvas de aprendizaje
\end_layout

\begin_layout Standard
Las curvas de aprendizaje se componen por dos líneas de puntos representadas
 en el mismo plano cartesiano.
 Ambas líneas grafican el error de predicción utilizando los dos métodos
 de evaluación conocidos, aplicando el conjunto de entrenamiento o el método
 de validación cruzada.Las curvas de aprendizaje implementadas por la herramienta
 son mostradas en la figura 4.15.
 
\end_layout

\begin_layout Standard
El procedimiento considera una cantidad de instancias determinadas, cantidad
 que se incrementa en un factor constante para aplicar el modelo y calcular
 el error cuadrático medio, es decir, la diferencia cuadrática entre el
 valor real del atributo y el predicho por el modelo.
 
\end_layout

\begin_layout Standard
En un primer paso, la herramienta toma en cuenta las primeras cinco instancias,
 luego las primeras diez, las primeras quince y así sucesivamente para conformar
 cada punto del dominio cuyo valor de ordenada es el error cuadrático, error
 añadido en la herramienta como parte del conjunto de métricas consideradas.
 Por cuestiones de facilitar la vista se impuso un límite en los valores
 del dominio reducido en trescientas (300) instancias en caso de que el
 conjunto de entrenamiento supere dicha cantidad.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FIGURA 15??
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Opciones para el usuario
\end_layout

\begin_layout Standard
En Nekonata se han incluido dos acciones posibles para reparar, en caso
 de evidenciar, los efectos de overfit o underfit del modelo.
 Estas dos acciones no son mutuamente excluyentes de manera que el usuario
 puede elegir libremente alguna o ambas acciones a la vez, sin embargo,
 la herramienta le recomienda la acción que debería tomar en caso de un
 efecto u otro.
 Ambas acciones realizan una transformación en la base de datos, cuando
 el usuario decide incorporar nuevas instancias o ejemplos del dominio introduce
 un archivo el cuál es parseado al formato conocido por la librería de uso
 y es unido al conjunto original siendo ahora, el nuevo conjunto de datos.
 Por otro lado, cuando el usuario decide aumentar el grado del polinomio
 que emplea el modelo, elige un número entre uno y cuatro para modificar
 este polinomio y así, añadir a la base de datos los nuevos atributos originario
s del nuevo polinomio completo para ese grado.
 
\end_layout

\begin_layout Subsubsection
Diseño e implementación
\end_layout

\begin_layout Standard
A pesar que la herramienta fue pensada para la predicción de componentes
 de android,se desarrolló como una aplicación de escritorio debido a la
 limitación del hardware de los dispositivos móviles para ejecutar los procesos
 de optimización que consumen un gran porcentaje de recursos computacionales.
 Esta implementación desvincula la herramienta de medición con la herramienta
 de entrenamiento y evaluación de modelos, permitiendo la ejecución independient
e entre ambas por lo que el puente de comunicación entre ellas es la corresponde
ncia entre la salida de la primer herramienta con la entrada de la segunda;
 la herramienta de medición crea archivos de formato 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{CSV}
\end_layout

\end_inset

, los cuales serán usados en la herramienta como el conjunto de datos fuente
 para el entrenamiento.
 
\end_layout

\begin_layout Subsubsection*
Entorno y tecnologías
\end_layout

\begin_layout Standard
Para la implementación del framework Nekonata se utilizó el entorno de desarroll
o Eclipse cuyo lenguaje de programación es Java.
 El proyecto ha sido configurado con la versión 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{JDK}
\end_layout

\end_inset

 1.7 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{JRE}
\end_layout

\end_inset

 1.8 y además, se han incorporado tecnologías de terceros para el entorno
 las cuáles cumplen distintos roles en la herramienta.
 
\end_layout

\begin_layout Standard
Para el diseño de la interfaz gráfica se utilizó mayormente la librería
 SWING de java incorporada en el 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{JDK}
\end_layout

\end_inset

 aunque también se incluyeron componentes de la librería nativa AWT.
 La principal ventaja de la librería SWING es brindar una interfaz adaptada
 a cada sistema operativo sin necesidad de cambio de código, es decir independie
nte a la plataforma.
 Complementariamente se incorporaron las dos siguientes librerías: 
\emph on
jgoodies-forms-1.8.0.jar
\emph default
 y 
\emph on
miglayout15-swing.jar
\end_layout

\begin_layout Standard
Por otro lado, para la creación de vistas para el usuario se incorporó la
 biblioteca gráfica de Java JFREECHART que facilita la creación de varios
 tipos de gráficos profesionales, en el caso de la herramienta se han utilizado
 los gráficos de barras y lineales para representar la información requerida
 por el usuario.
 Esta biblioteca ha sido elegida por brindar objetos de alta calidad y ofrecer
 una extensa gama de funciones para reforzar y mejorar la información mostrada
 en los gráficos.
 Se utilizó la versión 1.0.19 de la biblioteca en complemento con la librería
 JCOMMON en la versión 1.0.23.
 
\end_layout

\begin_layout Standard
Respecto al uso de técnicas de aprendizaje de máquina, actualmente existen
 muchas tecnologías y frameworks que proveen esta funcionalidad para utilizar
 en entornos Java, sin embargo, como se ha adelantado anteriormente en la
 herramienta sólo se incluyó la biblioteca 
\emph on
Weka
\emph default
 en la versión 3.8 y se añadió también un paquete para la optimización de
 parámetros perteneciente a la misma librería denominado MULTISEARCH en
 su versión más actual del mes de agosto del 2016.
 
\end_layout

\begin_layout Subsubsection*
Diseño
\end_layout

\begin_layout Standard
Considerando todo lo anteriormente descrito, el concepto principal de la
 herramienta fue la extensibilidad de la misma desde todos los enfoques
 posibles.
 Esto significa que la herramienta pudiera aceptar diferentes tipos de librerías
 de aprendizaje de máquina, datasets, modelos de regresión, parámetros y
 métricas; lo que conlleva a un gran grado de abstracción de las clases
 que conforman la aplicación y, por lo tanto, se consideró importante la
 asociación de mismas, para un entendimiento mayor de parte de un nuevo
 desarrollador.
\end_layout

\begin_layout Standard
La finalidad de la etapa de implementación fue un buen framework de trabajo
 para el futuro desarrollo de modelos, librerías y métricas.
 Si bien la herramienta sólo trabaja con Weka actualmente y la mayoría de
 su funcionalidad es enteramente parser , se considera que el grado de abstracci
ón es lo bastante elevado para poder soportar la finalidad deseada.
\end_layout

\begin_layout Standard
Aplicando los conceptos teóricos antes presentados, se exponen a continuación
 los paquetes y las clases principales que componen el desarrollo de Nekonata.
 
\end_layout

\begin_layout Paragraph*
Databases
\end_layout

\begin_layout Standard
Como ya se mencionó anteriormente se desea poder administrar, leer y escribir
 datasets de forma dinámica y segura.
 Para esto, se creó una estructura para almacenar cada individuo (instancia)
 con una estructura 
\emph on
Hashtable
\emph default
, con los nombres de los atributos como claves de los valores numéricos
 que representan a cada uno de ellos.
\end_layout

\begin_layout Standard
Asimismo, se desarrolló un conjunto para representar los datasets ya que
 son estos las bases de los modelos, del aprendizaje y del framework, tomando
 como entrada un csv y creando la base de datos necesaria para el correcto
 funcionamiento de la aplicación.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/database-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de clases de las bases de datos implementadas
\begin_inset CommandInset label
LatexCommand label
name "fig:database-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Modelos
\end_layout

\begin_layout Standard
Los modelos que la herramienta presenta son de tipo regresivo pero no necesariam
ente son modelos intrínsecamente predictivos y por eso el framework presenta
 una división clara entre modelos regresivos y clasificadores (siempre considera
ndo que estos últimos se utilizan para la regresión).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/modelers-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de clases de los modelos base implementados.
\begin_inset CommandInset label
LatexCommand label
name "fig:modelers-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A partir de esto, implementando los métodos abstractos presentados, se pueden
 incluir cualquier método de clasificación requerido, siempre considerando
 importante que retorne un valor denso.
 Actualmente, los modelos implementados son los presentados en la sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Funciones-contempladas"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/all-modelers-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de la relación entre los modelos implementados.
\begin_inset CommandInset label
LatexCommand label
name "fig:all-modelers-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se puede apreciar en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:all-modelers-class-diagram"

\end_inset

 , se realizó una abstracción intermedia considerando la librería Weka.
 Esto se debe principalmente al comportamiento en común que tenían dichos
 modelos, pero no es mandatoria dicha abstracción al agregar una nueva librería
 o al agregar nuevos modelos.
 
\end_layout

\begin_layout Standard
Ya que el diseño fue impulsado por la necesidad de abstracción e independencia
 de las librerías subyacentes, se considera importante la posibilidad de
 que en un futuro cualquier desarrollador pueda incorporar modelos implementados
 de forma particular.
 
\end_layout

\begin_layout Paragraph
Parámetros
\end_layout

\begin_layout Standard
Para implementar los modelos, la iniciativa fue modelar el concepto teórico
 que los rige: funciones.
 Como ya fue explicado, las funciones están moldeados por variables y parámetros.
 Las variables son aquellos atributos modelados por la Hashtable en la clase
 individuo.
 Debido a los modelos considerados en el apartado anterior, los parámetros
 (o las constantes de una función) fueron modeladas en dos partes:
\end_layout

\begin_layout Enumerate
Parámetros simples: Son aquellos que sólo tienen un valor numérico y que
 tiene un valor único en la función.
 Rigen en funcionamiento del método de aprendizaje y determinan la calidad
 y finalidad que tendrán los mismos.
 Estos tipos de parametros se utilizan en todo el core de modelos ya que
 son la idea fundamental de cualquier función matemática.
 
\end_layout

\begin_layout Enumerate
Parámetros kernel: Son funciones matemáticas que se emplean en las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{SVM}
\end_layout

\end_inset

.
 Estas funciones son las que le permiten convertir lo que sería un problema
 de clasificación no lineal en el espacio dimensional original, a un sencillo
 problema de clasificación lineal en un espacio dimensional mayor.
 Debido a que estas son funciones dentro de los modelos, es conveniente
 el modelado de las mismas de forma particular.
\end_layout

\begin_layout Standard
Observando ambos puntos, se puede apreciar una composición de parámetros
 ya que las funciones se conforman por parámetros simples y los parámetros
 kernel son funciones internas.
 Esto se puede observar en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:parameters-class-diagram"

\end_inset

 .
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/parameters-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de clases de los parametros implementados
\begin_inset CommandInset label
LatexCommand label
name "fig:parameters-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Métricas
\end_layout

\begin_layout Standard
Otra parte importante de la implementación de la herramienta es la capacidad
 de la misma de cuantificar y valorizar los modelos obtenidos.
 Las mismas ya vienen implementadas por la librería Weka, pero considerando
 la finalidad de abstraer comportamiento, las mismas fueron parseadas y
 se crearon nuevas clases.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/metrics-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de clases de las métricas implementadas.
\begin_inset CommandInset label
LatexCommand label
name "fig:metrics-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La implementación presentada surge a partir de la forma de implementación
 que tiene la librería weka.
 La misma presenta una clase que representa la relación entre los valores
 reales que presenta la base de datos y los valores calculados por el modelo.
 Sin embargo, la librería presenta la particularidad de solo calcular métricas
 de los modelos que la misma toma como de regresión.
 Así, el Simple K clusterer quedaría excluido de este grupo y, por lo tanto,
 no podría ser valorado.
 La implementación planteada permite que este modelo quede a la altura de
 los otros presentados y que, si se desea, se pueden crear nuevas métricas
 sin tener la clase 
\emph on
AbsEvaluation
\emph default
 que represente esta relación.
 Sólo sería necesario crear la métrica heredando de 
\emph on
AbsSimpleMetric
\emph default
 e implementar la forma de cálculo requerida.
\end_layout

\begin_layout Paragraph*
Optimización
\end_layout

\begin_layout Standard
El paquete que se procede a explicar es implementado principalmente considerando
 la función que proviene de Weka, permitiendo la prueba de varios valores
 para los parámetros sin necesidad de pruebas constantes, apuntando a una
 mejor y más rápida optimización del modelo.
 Puede omitirse dicha implementación si se desea agregar un nuevo modelo,
 pero es conveniente la explicación del mismo para futuras adaptaciones
 de modelos de weka que se quieran agregar o de librerías que tengan esta
 posibilidad también.
 
\end_layout

\begin_layout Standard
La idea del paquete de optimización es que, de forma transparente para el
 usuario de la aplicación, el modelo consiga adaptarse a la base de datos
 analizada.
 Esto permite que la aplicación NOMBRE DE LA TESIS pueda adaptarse a grandes
 rangos de valores objetivo.
 Como ya se dijo anteriormente, no es un paquete necesario en la aplicación
 ya que los parámetros pueden ser puestos de forma fija en un modelo, pero
 esto restringe el rango y las posibilidades del mismo.
 
\end_layout

\begin_layout Standard
Los optimizadores cumplen la función de probar valores para los parámetros
 y se quedan con aquellos que minimizan el grado de error del modelo.
 Asimismo, cabe destacar que Weka proporciona dos tipos de optimizadores.
 Los primeros son los simples, que consideran cada parámetro del modelo
 desde un valor al otro.
 Los segundos son los kernels y prueban valores no solo para los parámetros
 propios de los modelos sino para los parámetros que conforman los kernels.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/optimizer-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de clases de los optimizadores implementados.
\begin_inset CommandInset label
LatexCommand label
name "fig:optimizer-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Cómo agregar clases nuevas
\end_layout

\begin_layout Standard
Todo lo anteriormente planteado se mantiene coherente y de forma congruente
 gracias a la clase librería y lo que conlleva agregarla a la aplicación.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/library-class-diagram.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de clases de las librerias y las relaciones con los otros objetos.
\begin_inset CommandInset label
LatexCommand label
name "fig:library-class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al crear la librería, y como se ve en el diagrama de clases, se deben implementa
r dos métodos que devuelven dos conceptos principales.
 Por un lado, un objeto de tipo Database que ya se explicó anteriormente.
 Por el otro, un objeto MetricsCollection.
 Este último representa el conjunto de métricas que sirven para valorizar
 los modelos.
 
\end_layout

\begin_layout Standard
Ya implementado se provee el conjunto 
\emph on
SimpleMetricsCollection
\emph default
 que permiten valorizar cualquier modelo, ademas del 
\emph on
WekaMetricsCollection
\emph default
 que sólo contiene la metricas basadas en el 
\emph on
WekaEvaluation
\emph default
.
 
\end_layout

\begin_layout Standard
La última función que se debe implementar de forma ineludible retorna un
 vector de constantes.
 Estas constantes deben estar declaradas en la clase 
\emph on
Config.Modeler
\emph default
 con el formato: 
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Nombre a mostrar en la aplicación: constante 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las mismas declaran los modelos que son aceptados por la liberia.
 Esto se hace a modo de índice para los modelos y, al momento de utilizar
 la herramienta, las clases de los modelos sean creadas al momento de ser
 seleccionadas.
 Esto se permite implementando la última función: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract Vector<AbsModeler> createModelers(Vector<Integer> selectedModels
, int index); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta última función crea la relación entre la constante con las clases que
 se deben crear para representar a los modelos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Desktop/Tesis rubbish/tesis/images/config-correlation.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama conceptual de la configuración que presenta la herramienta
\begin_inset CommandInset label
LatexCommand label
name "fig:config-correlation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
