#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default"
\font_sans "default"
\font_typewriter "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author -322385837 "Emiliano" 
\author 1188755597 "usuario" 
\end_header

\begin_body

\begin_layout Chapter
Marco Teórico
\begin_inset CommandInset label
LatexCommand label
name "chap:Marco-Teorico"

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se presentan los conceptos fundamentales del dominio, el
 cual está centrado en torno a la predicción de performance y precisión
 de componentes de software en dispositivos móviles.
\end_layout

\begin_layout Section
Dispositivos Móviles
\begin_inset CommandInset label
LatexCommand label
name "sec:Dispositivos-móviles"

\end_inset


\end_layout

\begin_layout Standard
Los dispositivos móviles son artefactos electrónicos pequeños que se alimentan
 a través de una batería de litio.
 En este contexto, un smartphone o teléfono inteligente es un teléfono móvil
 con una mayor capacidad de cómputo y conectividad que un teléfono móvil
 convencional.
 Mientras el teléfono móvil es un dispositivo inalámbrico electrónico utilizado
 para acceder y utilizar los servicios de la red de telefonía celular, el
 término 
\emph on
inteligente
\emph default
 hace referencia a la capacidad de usarlo también como una computadora de
 bolsillo.
\end_layout

\begin_layout Standard
Una de las características más destacadas de los smartphones reside en la
 posibilidad que brindan de instalar aplicaciones mediante las cuales el
 usuario final logra ampliar las capacidades y funcionalidades del equipo,
 obteniendo así una personalización total del dispositivo.
 Otras características importantes son la capacidad multitarea, el acceso
 y conectividad a Internet vía WiFi o red movil, el soporte de clientes
 de email, la eficaz administración de datos y contactos, la posibilidad
 de lectura de archivos en diversos formatos como .pdf o .doc, y la posibilidad
 de obtener datos del ambiente a través de sensores especializados como
 el acelerómetro y el sistema de posicionamiento global conocido como GPS
 por sus siglas en inglés, entre otros.
 
\end_layout

\begin_layout Standard
Para poder ejecutar aplicaciones en los dispositivos móviles, los mismos
 poseen, al igual que las computadoras, sistemas operativos.
 Un sistema operativo es un intermediario entre el usuario de un dispositivo
 y el hardware del mismo.
 El objetivo de un sistema operativo es proveer un ambiente en el cual el
 usuario pueda ejecutar programas en un manera conveniente y eficiente.
 Un sistema operativo es software que administra el hardware del dispositivo.
 El hardware debe proveer mecanismos apropiados para asegurar la operación
 correcta de un sistema y evitar a los usuarios interferir con el funcionamiento
 apropiado del mismo.
 
\end_layout

\begin_layout Standard
Entre los sistemas operativos más populares en dispositivos móviles se encuentra
 Android.
 En las secciones siguientes se describe detalladamente este sistema y la
 framework que provee para el desarrollo de aplicaciones.
 
\end_layout

\begin_layout Subsection
Android 
\begin_inset CommandInset label
LatexCommand label
name "sec:Android"

\end_inset


\end_layout

\begin_layout Standard
Android es un sistema operativo de código abierto diseñado para dispositivos
 móviles tales como smartphones y tablets.
 Este sistema operativo está basado en un kernel Linux y es desarrollado
 por Google.
 El mismo cuenta con un middleware extensible y aplicaciones de usuario.
 Adicionalmente, posee una plataforma de distribución de aplicaciones disponible
 a partir de la versión 2.2 del sistema, denominada Google Play
\begin_inset Foot
status open

\begin_layout Plain Layout
https://play.google.com
\end_layout

\end_inset

, que permite a los usuarios navegar y descargar aplicaciones que más se
 ajusten a sus necesidades y preferencias, personalizando de esta forma
 el dispositivo sencillamente.
 Por otro lado, también provee un framework para el desarrollo de aplicaciones
\begin_inset Foot
status open

\begin_layout Plain Layout
https://developer.android.com
\end_layout

\end_inset

 que utiliza Java como lenguaje de su interfaz (API).
 
\end_layout

\begin_layout Standard
La plataforma Android utiliza la máquina virtual Dalvik (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{DVM}
\end_layout

\end_inset

) para ejecutar aplicaciones programadas en Java a partir de la versión
 5.
 Debido al escaso poder de procesamiento y memoria limitada de los dispositivos
 que ejecutan Android, no fue posible utilizar la máquina virtual Java estándar
 por lo que la compañía Google tomó la decisión de crear una nueva, la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{DVM}
\end_layout

\end_inset

, que fue optimizada para requerir poco uso de memoria y diseñada para ejecutar
 en simultáneo múltiples instancias de la máquina virtual, delegando en
 el sistema operativo Android subyacente el soporte para el aislamiento
 de procesos, la gestión de memoria e hilos de ejecución.
 
\end_layout

\begin_layout Standard
En la figura
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Android-architecture"

\end_inset

 se puede ver la arquitectura en capas empleada por el sistema Android.
 Las diferentes capas de la arquitectura son descritas a continuación:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/Android-architecture.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de la arquitectura en capas empleada por Android
\begin_inset CommandInset label
LatexCommand label
name "fig:Android-architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Kernel Linux: Android utiliza el núcleo de Linux como una capa de abstracción
 de hardware para los dispositivos móviles.
 Esta capa contiene los drivers necesarios para que cualquier componente
 de hardware pueda ser utilizado mediante las llamadas correspondientes,
 sólo debe considerarse al momento de incluir un nuevo componente de hardware
 que los fabricantes hayan desarrollado los drivers correspondientes.
 Además del soporte de drivers, la capa es responsable de proporcionar otros
 servicios como la seguridad, el manejo de la memoria, procesos, etc.
 
\end_layout

\begin_layout Itemize
Entorno de ejecución de Android: como se ha adelantado previamente, cada
 aplicación corre en su propio proceso Linux con su propia instancia de
 la máquina virtual Dalvik, la cual interpreta un lenguaje ligeramente diferente
 al tradicional bytecode de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{JVM}
\end_layout

\end_inset

.
 A partir de la versión 5.0 de Android, Dalvik es reemplazada por 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{ART}
\end_layout

\end_inset

 la cual logra reducir el tiempo de ejecución del código Java hasta un 33%.
 También se incluye en el entorno un módulo de librerías nativas con la
 mayoría de librerías disponibles en lenguaje Java.
 Estas bibliotecas, si bien resultan diferentes a las ofrecidas por 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{Java SE}
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{Java ME}
\end_layout

\end_inset

, proveen prácticamente la misma funcionalidad.
 
\end_layout

\begin_layout Itemize
Bibliotecas: incluye un conjunto de bibliotecas nativas escritas en lenguaje
 C y C++ usadas en varios componentes de Android que proporcionan la mayor
 parte de las características de Android.
\end_layout

\begin_layout Itemize
Marco o framework de Aplicaciones: este es el framework que proporciona
 Android para el desarrollo de aplicaciones, servicios y otros componentes.
 Todo el conjunto de funciones del sistema operativo y bibliotecas nativas
 está disponible a travez de este framework, cuya API esta escrita en el
 lenguaje Java.
 El framework permite que los desarrolladores tengan acceso a las mismas
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{API}
\end_layout

\end_inset

 utilizadas por las aplicaciones base del sistema.
 El foco principal del diseño de esta capa ha sido simplificar la reutilización
 de componentes: las aplicaciones pueden publicar sus capacidades y otras
 pueden hacer uso de ellas (sujetas a restricciones de seguridad), un mecanismo
 que permite a los usuarios reemplazar fácilmente componentes.
 
\end_layout

\begin_layout Itemize
Aplicaciones: Este nivel contiene todas las aplicaciones de usuario, tanto
 las incluidas por defecto en Android así como como aquellas que el usuario
 vaya añadiendo posteriormente ya sean de terceros o de su propio desarrollo.
 Todas estas aplicaciones utilizan los servicios, las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{API}
\end_layout

\end_inset

 y bibliotecas de los niveles inferiores.
 Se brindará una descripción más detallada en la siguiente sección.
\end_layout

\begin_layout Subsection
Aplicaciones Android 
\begin_inset CommandInset label
LatexCommand label
name "sec:Aplicaciones-Android"

\end_inset


\end_layout

\begin_layout Standard
Además de las características técnicas, es importante resaltar que la popularida
d de Android ha crecido muy rápidamente desde su lanzamiento.
 Esto se debe a la versatilidad que Android otorga a los dispositivos a
 través de las aplicaciones, que permiten adaptarlos según las necesidades
 de los usuarios.
 Android también permite que las aplicaciones se adapten a las características
 del dispositivo (pantalla, sensores, etc.), aprovechando las capacidades
 particulares de cada uno.
 
\end_layout

\begin_layout Standard
Un aspecto clave del diseño de las aplicaciones en Android es que éstas
 pueden reutilizar componentes de otras aplicaciones instaladas en el dispositiv
o.
 Por ejemplo, si una aplicación desea tomar una fotografía, es probable
 que ya exista una aplicación que cumpla esa funcionalidad, entonces, la
 nueva aplicación puede utilizar la existente sin necesidad de desarrollar
 una actividad propia para utilizar la cámara, esta invocación se realiza
 de modo tal que sea transparente para el usuario final.
\end_layout

\begin_layout Standard
El sistema Android provee cinco tipos de componentes básicos para el desarrollo
 de aplicaciones: Activity, Service, Content Provider, Broadcast Receiver
 e Intent.
 El componente 
\emph on
Activity 
\emph default
representa una pantalla simple que provee interfaz de usuario.
 Una aplicacion puede estar formada por una o mas actividades que trabajan
 en conjunto y representan diferentes pantallas o vistas.
 
\end_layout

\begin_layout Standard
Los
\emph on
 Content Providers
\emph default
 son los encargados de administrar la información compartida por las aplicacione
s.
 Las aplicaciones pueden almacenar sus datos en el sistema de archivos,
 en una base de datos SQLite, en la Web, o en cualquier otro lugar de acceso.
 A través del 
\emph on
content provider
\emph default
, otras aplicaciones pueden consultar, o incluso modificar estos datos.
 
\end_layout

\begin_layout Standard
Las aplicaciones también pueden iniciar servicios que se ejecutan en segundo
 plano para realizar operaciones que requieran gran cantidad de tiempo,
 o interactúen con procesos remotos, por ejemplo la reproducción de música
 en segundo plano o la descarga de datos mientras el usuario interactúa
 con una aplicación diferente.
 
\end_layout

\begin_layout Standard
El componente 
\emph on
Intent
\emph default
 es un objeto de acción que facilita la comunicación entre componentes.
 Un intent puede verse como un mensaje entre componentes, por ejemplo, para
 iniciar una actividad o servicio, o solicitar una accion.
 Por último, el componente 
\emph on
Broadcast Receiver
\emph default
 funciona como puerta de enlace a otros componentes, respondiendo a los
 anuncios (Intents) originados por el sistema u otras aplicaciones, por
 ejemplo, cuando la pantalla se apaga, la batería es baja, o al capturar
 una fotografía.
 
\end_layout

\begin_layout Section
Componentes de software
\begin_inset CommandInset label
LatexCommand label
name "sec:Componentes-de-software"

\end_inset


\end_layout

\begin_layout Standard
En el marco del desarrollo de software nos encontramos con la posibilidad
 de reutilizar código previamente desarrollado, testeado y deployado que
 cumple con una determinada funcionalidad, ahorrando tiempo y esfuerzo al
 desarrollador.
 Estas piezas de códigos ya implementadas se distribuyen como componentes
 de software que encapsulan a un conjunto de funciones y datos relacionados.
 
\end_layout

\begin_layout Standard
La reutilización es uno de los objetivos principales al momento de diseñar
 un componente de software de calidad para ser usado en diferentes programas.
 La comunicación entre componentes se realiza a través de interfaces.
 Cuando un componente ofrece servicios al resto del sistema, el mismo proporcion
a una interfaz que especifica los servicios que otros componentes pueden
 utilizar y la manera en que pueden hacerlo.
 La interfaz puede verse como una firma del componente ya que el cliente
 no necesita conocer el procesamiento interno del componente para utilizarlo,
 condición que respeta el principio de encapsulamiento.
 Por otro lado, cuando un componente necesita de otro para su funcionamiento,
 el mismo establece las interfaces requeridas donde especifica los servicios
 que necesita.
 De acuerdo al lenguaje de modelado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{UML}
\end_layout

\end_inset

, las interfaces proporcionadas por componentes son representadas con símbolos
 de lollipop en el borde del componente y las interfaces requeridas por
 medio de sockets abiertos en el borde externo, como se ilustra en la figura
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UML-component"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/UML-component.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Componente UML con interfaces proveídas y requeridas.
\begin_inset CommandInset label
LatexCommand label
name "fig:UML-component"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otra de las características fundamentales de los componentes es su capacidad
 de ser sustituidos tanto en tiempo de diseño como en tiempo de ejecución,
 pudiendo ser reemplazados por actualizaciones u otras alternativas sin
 romper el sistema en el que los componentes funcionan.
 El reemplazo es posible si el componente sucesor provee al menos la misma
 funcionalidad que el componente a reemplazar y si requiere a lo sumo las
 mismas funciones que el componente inicial.
 
\end_layout

\begin_layout Section
Atributos de calidad 
\begin_inset CommandInset label
LatexCommand label
name "sec:Atributos-de-calidad"

\end_inset


\end_layout

\begin_layout Standard

\lang spanish-mexico
Además de su interfaz y funcionalidad, los componentes de software se caracteriz
an por un conjunto de propiedades que representan los aspectos no-funcionales
 o de calidad de servicio, llamados propiedades o atributos de calidad.
 Estas propiedades son características medibles que utilizan los usuarios
 para juzgar su funcionamiento
\begin_inset space ~
\end_inset

[Referencia a 
\begin_inset Quotes eld
\end_inset

Software Architecture in Practice
\begin_inset Quotes erd
\end_inset

].
 Algunos ejemplos de estas propiedades son: el tiempo de respuesta, la disponibi
lidad, etc.
 
\change_inserted 1188755597 1492727922

\end_layout

\begin_layout Standard
Al diseñar un sistema de software no sólo se espera cumplir con los objetivos
 de negocio sino también alcanzar un determinado grado de calidad de software
 capaz de satisfacer al grupo de usuarios y/o diseñadores.
 El diseño de la arquitectura de un sistema depende mayormente de los atributos
 de calidad demandados por los stakeholders.
 Largos tiempos de respuesta, caídas del sistema, interfaces confusas, no
 son características deseables en un sistema, por lo que toda decisión respecto
 al diseño de la arquitectura debe conducir al cumplimiento de ciertos atributos
 de calidad al mismo tiempo que cumple con la funcionalidad requerida.
\end_layout

\begin_layout Standard
Estos atributos de calidad se pueden dividir en dos grupos en base al momento
 en el cual son medidos.
 Un grupo incluye atributos cuantificados durante el tiempo de diseño como
 la escalabilidad, modificabilidad, etc.
 El segundo grupo incluye atributos cuantifiables mientras el sistema se
 ejecuta como usabilidad, seguridad, etc.
 Este trabajo se enfoca en la predicción de propiedades dinámicas o en tiempo
 de ejecución.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Hacer una pequeña distincion de que en este trabajo se consideran propiedades
 no-funcionales en tiempo de ejecucion, como performance (No propiedades
 como modificabilidad o testabilidad, etc).
 
\end_layout

\end_inset

A continuación se describen las dos propiedades consideradas en la evaluación
 del enfoque.
 
\end_layout

\begin_layout Subsection*
Tiempo de respuesta
\begin_inset CommandInset label
LatexCommand label
name "subsec:Atributos-de-calidad-Performance"

\end_inset


\end_layout

\begin_layout Standard
Se puede medir la calidad de un sistema a través de su desempeño (performance)
 evaluando la efectividad del uso de los recursos disponibles en tiempo
 de ejecución.
 Dependiendo el contexto, el desempeño puede medirse a través de varias
 propiedades, como el tiempo de respuesta o la latencia.
 El rendimiento de un sistema engloba, generalmente, el tiempo de los eventos
 que se producen y que el sistema debe responder a ellos.
 Estos eventos pueden ser muy variados tales como alarmas, mensajes, peticiones
 a usuarios o procesamiento, pero básicamente se considera de todos ellos
 el tiempo que tarda el sistema para responder al evento.
 La complejidad para el manejo de estos eventos radica en su fuente, ya
 que pueden provenir desde una solicitud de usuario, de otros sistemas o
 desde el interior del propio sistema.
 
\end_layout

\begin_layout Subsection*
Precisión
\begin_inset CommandInset label
LatexCommand label
name "subsec:Atributos-de-calidad-Precisión"

\end_inset


\end_layout

\begin_layout Standard
Cabe destacar que no existe una definición estándar sobre el significado
 de precisión en un sistema, ya que se trata de una medida que evalúa qué
 tan exacta es la respuesta de una funcion (operación) de un componente,
 y cada función está ligada a resolver un problema o funcionalidad particular.
 Por ejemplo, en un problema de detección de rostros, la precisión puede
 medirse como la cantidad de rostros correctamente detectados sobre los
 rostros totales presentes, y en un problema de optimizacion puede significar
 el grado de cercanía del valor de la solución encontrada respecto a la
 solución óptima.
\end_layout

\begin_layout Section
Aprendizaje de máquina 
\begin_inset CommandInset label
LatexCommand label
name "sec:Aprendizaje-de-maquina"

\end_inset


\end_layout

\begin_layout Standard
El aprendizaje de máquina 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Incluir referencia a Aprendizaje de Maquina: Michalski, R.
 S., Carbonell, J.
 G., & Mitchell, T.
 M.
 (Eds.).
 (2013).
 Machine learning: An artificial intelligence approach.
 Springer Science & Business Media.
\end_layout

\end_inset

 o aprendizaje automático es una rama de la inteligencia artificial cuyo
 objetivo es desarrollar técnicas que permitan a las computadoras 
\emph on
aprender
\emph default
 a partir de datos suministrados en forma de ejemplo.
 El aprendizaje a partir de datos es la base para comprender el proceso
 de aprendizaje de máquina ya que los datos son la única herramienta de
 la que se dispone y conoce a ciencia cierta sobre las características de
 un dominio cualquiera.
 El aprendizaje de máquina puede entenderse haciendo una analogía con el
 aprendizaje humano basado en la experiencia, en donde el hombre basa su
 conocimiento en tres partes: 
\emph on
i
\emph default
) recuerdo, el hombre reconoce cuando ha sido la última vez que estuvo en
 una determinada situación (dataset), 
\emph on
ii
\emph default
) adaptación, reconoce la última vez que se probó una acción (salida producida)
 y 
\emph on
iii
\emph default
) generalización, reconoce si ha funcionado o no esta acción (si fue correcta
 o no).
 El término generalización refiere a la similitud entre diferentes situaciones
 de manera tal que las opciones que han sido aplicadas en casos previos
 pueden ser usadas en nuevos casos.
\end_layout

\begin_layout Standard
El aprendizaje de máquina, entonces, es un proceso para que las computadoras
 modifiquen o adapten sus acciones (predictivas o de control) para que sus
 resultados sean más precisos, precisión que refleja la proximidad respecto
 a las acciones correctas.
 El aprendizaje de máquina reúne ideas de neurociencia, biología, estadística,
 matemática y física, para generar técnicas y hacer que la computadora aprenda.
 Un área importante relacionada con el aprendizaje de máquina es la minería
 de datos, el proceso de extraer información útil de un conjunto de datos
 masivos por medio de algoritmos eficientes.
 
\end_layout

\begin_layout Standard
Si se define el aprendizaje de máquina como la mejora de tareas a través
 de la experiencia, surge el cuestionamiento de como la computadora puede
 saber si está aprendiendo mejor o de qué forma podría mejorar ese aprendizaje.
 De aquí, surgen diferentes tipos de técnicas o algoritmos de aprendizaje.
 Por ejemplo, se le puede indicar a un algoritmo la respuesta correcta para
 un problema, así, la próxima vez que se aplique su desempeño será mejor.
 También, podría indicarse un conjunto de respuestas correctas para que
 el algoritmo 
\emph on
adivine
\emph default
 la forma de obtener estas respuestas para otros problemas (generalización).
 Alternativamente, se puede indicar si la respuesta obtenida es correcta
 o no sin señalar la respuesta real, que el algoritmo debería ser capaz
 de encontrar.
 Una variante podría ser asignarle un puntaje a la respuesta obtenida por
 el algoritmo que indique cuán correcta resulta ser.
 
\end_layout

\begin_layout Standard
Estas diferentes alternativas proveen una forma de clasificar las diferentes
 métodos de aprendizaje que será detallada en la siguiente sección.
 Cabe destacar que por más que existan distintos tipos de aprendizaje, todos
 los métodos comparten el mismo objetivo de generalización: la técnica debe
 producir salidas sensibles para datos de entrada que no fueron encontrados
 durante el aprendizaje, teniendo en cuenta también que el algoritmo debe
 lidiar con ruido en los datos, es decir, imprecisión en los valores que
 es inherente a la medición de cualquier proceso real.
 
\end_layout

\begin_layout Subsection
Clasificación de las técnicas de aprendizaje
\change_inserted -322385837 1492373857

\end_layout

\begin_layout Standard

\change_inserted -322385837 1492373860
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -322385837 1492380729
Simplificar esta seccion y la siguiente en una sola, considerando la siguiente
 clasificacion:
\end_layout

\begin_layout Itemize

\change_inserted -322385837 1492380958
Aprendizaje supervisado: los datos de entrenamiento tienen definido un atributo
 clase.
 Una tecnica de aprendizaje supervisado tiene como objetivo entrenar modelos
 para predecir este atributo en entradas futuras.
\end_layout

\begin_deeper
\begin_layout Itemize

\change_inserted -322385837 1492374090
Classificacion: el atributo clase es discreto
\end_layout

\begin_layout Itemize

\change_inserted -322385837 1492374100
Regression: el atributo clase es continuo
\end_layout

\end_deeper
\begin_layout Itemize

\change_inserted -322385837 1492374269
Aprendizaje no supervisado: los datos de entrenamiento no tienen definido
 un atributo clase.
\end_layout

\begin_deeper
\begin_layout Itemize

\change_inserted -322385837 1492380629
Clustering
\end_layout

\end_deeper
\begin_layout Itemize

\change_inserted -322385837 1492380635
Aprendizaje por refuerzo
\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
El modo de aprendizaje que un algoritmo particular puede realizar queda
 determinado por la naturaleza de los datos de entrada, es decir, 
\change_deleted -322385837 1492374729
puede variar en base a la información contenida en 
\change_unchanged
los datos de entrenamiento (
\emph on
training set
\emph default
).
 
\change_inserted -322385837 1492380559
Basicamente las tecnicas de aprendizaje se clasifican en tres grandes grupos:
 aprendizaje supervisado, no supervisado, y por refuerzo.
\change_unchanged

\end_layout

\begin_layout Standard
El aprendizaje supervisado utiliza un conjunto de datos basado en dos pares
 de objetos: los datos de entrada o conjunto de ejemplos del dominio y las
 respuestas correctas (
\emph on
targets
\emph default
) para una determinada característica
\change_deleted -322385837 1492374862
;
\change_inserted -322385837 1492374862
.

\change_unchanged
 
\change_deleted -322385837 1492374864
a
\change_inserted -322385837 1492374864
A
\change_unchanged
 través de las respuestas correctas provistas y basado en el conjunto de
 datos el algoritmo de aprendizaje generaliza el comportamiento para responder
 a todas las posibles entradas.
 Este modo de aprendizaje, entonces, es un proceso que se realiza mediante
 un entrenamiento controlado por un agente externo que determina la respuesta
 que debería generar el algoritmo a partir de una entrada determinada.
 
\change_inserted -322385837 1492375802

\end_layout

\begin_layout Standard

\change_inserted -322385837 1492375803
Dentro del aprendizaje supervisado, las técnicas se pueden separar en dos
 grupos de acuerdo a la naturaleza del atributo clase o respuesta.
 
\end_layout

\begin_layout Description

\change_inserted -322385837 1492375803
Clasificación Consiste en asignar a cada ejemplo una etiqueta o clase a
 la que pertenece basado en el entrenamiento de ejemplares de cada clase.
 Los datos de entrenamiento son instancias que pertenecen a una única clase
 y el conjunto de clases cubre todas las salidas posibles, por eso se considera
 al proceso de clasificación como un proceso discreto.
 El algoritmo de clasificación tiene como objetivo encontrar umbrales de
 decisión que sirvan para identificar las diferentes clases.
\end_layout

\begin_layout Description

\change_inserted -322385837 1492375803
Regresión El proceso de regresión predice valores numéricos de atributos
 a partir de funciones matemáticas polinomiales que describan o se ajusten
 lo más posible a todos los puntos del dominio, es decir, todos los valores
 del conjunto de entrenamiento correspondientes al atributo que se quiere
 predecir.
 Generalmente, se considera un problema de aproximación de función o interpolaci
ón al encontrar un valor numérico entre los valores conocidos.
 Por lo tanto, el eje primordial del proceso de regresión es encontrar la
 función que mejor represente al conjunto de puntos, ya que funciones con
 distintos grados de polinomios causan diferentes efectos.
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted -322385837 1492374937
Contrariamente, el aprendizaje por refuerzo se basa en la idea de no disponer
 de ejemplos completos del comportamiento deseado por el algoritmo, es decir,
 no indicar durante el entrenamiento exactamente la salida que se desea
 proporcione el clasificador ante una determinada entrada, sólo se le indica
 si la salida obtenida se ajusta a la deseada y en función a ello se re
 configuran los pasos.
 
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted -322385837 1492374940
Por último, e
\change_inserted -322385837 1492374940
E
\change_unchanged
n el aprendizaje 
\change_deleted -322385837 1492374952

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{Ghahramani2004}
\end_layout

\end_inset

 
\change_unchanged
no supervisado, la máquina simplemente recibe los datos de entrada sin etiquetas
 o respuestas correctas como en el método supervisado
\change_inserted -322385837 1492374991
,
\change_unchanged
 ni valores de recompensa desde el ambiente, dando lugar a una percepción
 misteriosa
\change_inserted -322385837 1492375007

\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -322385837 1492375019
percepcion misteriosa???
\change_unchanged

\end_layout

\end_inset


\change_unchanged
 sobre la forma que se espera que el método aprenda sin recibir ningún tipo
 de devolución.
 Sin embargo, es posible desarrollar un framework formal para llevar a cabo
 aprendizaje no supervisado basado en la noción de que el objetivo es construir
 una representación de la entrada que puede ser usada para tomar decisiones,
 predecir futuras entradas, comunicar eficientemente entradas para otras
 máquinas, entre otras posibilidades.
 
\change_inserted -322385837 1492375568

\end_layout

\begin_layout Standard
El aprendizaje no supervisado puede entenderse como la búsqueda de patrones
 en los datos independientemente del ruido presente en los mismos.
 
\change_inserted -322385837 1492375713
Por ejemplo, los algoritmos de agrupamiento (clustering) son tecnicas de
 aprendizaje no supervisado que agrupan un conjunto de objetos de modo tal
 que los objetos pertenecientes a un mismo grupo (
\emph on
cluster
\emph default
) comparten algún tipo de similitud entre ellos, de igual sentido que se
 diferencian con los objetos de otro grupo.
 A diferencia del proceso de clasificación, los grupos o clases no son conocidos
 fehacientemente antes del entrenamiento, un claro método de aprendizaje
 no supervisado.
 
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted -322385837 1492375072
Nótese que los valores de entrada y etiqueta describen vectores ya que cada
 ejemplo (
\emph on
instance
\emph default
) del conjunto de entrenamiento posee varias características (
\emph on
features
\emph default
); si se tuvieran todos los posibles ejemplos de un problema, no habría
 necesidad alguna de aprendizaje.
\change_inserted -322385837 1492380598

\end_layout

\begin_layout Standard

\change_inserted -322385837 1492380609
Por ultimo, el aprendizaje por refuerzo se basa en la idea de no disponer
 de ejemplos completos del comportamiento deseado por el algoritmo, es decir,
 no indicar durante el entrenamiento exactamente la salida que se desea
 proporcione el clasificador ante una determinada entrada, sólo se le indica
 si la salida obtenida se ajusta a la deseada y en función a ello se re
 configuran los pasos.
 
\change_unchanged

\end_layout

\begin_layout Subsection

\change_deleted -322385837 1492375099
Clasificación por la naturaleza de la salida
\end_layout

\begin_layout Standard

\change_deleted -322385837 1492375815
La teoría de aprendizaje de maquinas abarca varios factores considerando
 las características de lo que se busca en los diferentes métodos.
 Así, existen cinco tipos de métodos, para la búsqueda de diferentes objetivos:C
lasificación Consiste en asignar a cada ejemplo una etiqueta o clase a la
 que pertenece basado en el entrenamiento de ejemplares de cada clase.
 Los datos de entrenamiento son instancias que pertenecen a una única clase
 y el conjunto de clases cubre todas las salidas posibles, por eso se considera
 al proceso de clasificación como un proceso discreto.
 El algoritmo de clasificación tiene como objetivo encontrar umbrales de
 decisión que sirvan para identificar las diferentes clases.Clustering El
 proceso de clustering es la tarea de agrupar un conjunto de objetos de
 modo tal que los objetos pertenecientes a un mismo grupo (
\emph on
cluster
\emph default
) comparten algún tipo de similitud entre ellos, de igual sentido que se
 diferencian con los objetos de otro grupo.
 A diferencia del proceso de clasificación, los grupos o clases no son conocidos
 fehacientemente antes del entrenamiento, un claro método de aprendizaje
 no supervisado.
 
\change_unchanged

\end_layout

\begin_layout Description

\change_deleted -322385837 1492374681
Estimación
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

densidad La función de densidad de probabilidad 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{Silverman1986}
\end_layout

\end_inset

 es un concepto fundamental de la estadística y caracteriza el comportamiento
 probable de una población en tanto especifica la posibilidad relativa de
 que una variable aleatoria continua X tome un valor cercano a x.
\end_layout

\begin_layout Description

\change_deleted -322385837 1492374681
Reducción
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

dimesionalidad Se basa en simplificar los datos de entrada mapeándolos en
 un espacio dimensional más simple.
\change_unchanged

\end_layout

\begin_layout Description

\change_deleted -322385837 1492375405
Regresión El proceso de regresión predice valores numéricos de atributos
 a partir de funciones matemáticas polinomiales que describan o se ajusten
 lo más posible a todos los puntos del dominio, es decir, todos los valores
 del conjunto de entrenamiento correspondientes al atributo que se quiere
 predecir.
 Generalmente, se considera un problema de aproximación de función o interpolaci
ón al encontrar un valor numérico entre los valores conocidos.
 Por lo tanto, el eje primordial del proceso de regresión es encontrar la
 función que mejor represente al conjunto de puntos, ya que funciones con
 distintos grados de polinomios causan diferentes efectos.
 La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:regression-problems"

\end_inset

 refleja la situación expresada anteriormente, donde se muestra el conjunto
 de valores del dominio y tres curvas alternativas de representación.
 El gráfico inferior izquierdo combina, además, una función cúbica y línea
 recta.
 
\end_layout

\begin_layout Standard

\change_deleted -322385837 1492375355
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/regression-problems.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparación de distintas funciones polinomiales de regresión.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:regression-problems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted -322385837 1492375355
La forma más correcta de saber cuál solución presentada es la mejor, se
 evalúa el grado de generalización que permite cada una; se toma algún punto
 incluido entre los puntos ya representados y se utiliza la curva para predecir
 el valor, luego se compara entre los valores para saber cual resultó más
 próximo.
 En este caso, el gráfico inferior derecho.
 
\end_layout

\begin_layout Standard

\change_deleted -322385837 1492381647
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\change_deleted -322385837 1492381646
Cabe destacar que en el presente trabajo, se analizan técnicas de regresión,
 ya sea aquellas que intrínsecamente representan funciones polinomiales
 como aquellas que se adaptaron desde los métodos de clustering para la
 obtención de valores densos.
\change_unchanged

\end_layout

\begin_layout Subsection

\change_deleted -322385837 1492369776
Funciones
\change_inserted -322385837 1492381341
Técnicas
\change_unchanged
 contempladas
\begin_inset CommandInset label
LatexCommand label
name "subsec:Funciones-contempladas"

\end_inset


\end_layout

\begin_layout Standard
El foco principal del trabajo 
\change_inserted -322385837 1492381994
es el desarrollo de un enfoque
\change_deleted -322385837 1492382015
desarrollado ha sido guiado por la búsqueda de
\change_unchanged
 
\change_inserted -322385837 1492382032
para predecir
\change_deleted -322385837 1492382033
predicción
\change_unchanged
 
\change_inserted -322385837 1492381468
propiedades no-funcionales
\change_deleted -322385837 1492381470
de valores numéricos
\change_unchanged
 
\change_inserted -322385837 1492382069
de
\change_deleted -322385837 1492382070
sobre
\change_unchanged
 componentes 
\change_inserted -322385837 1492381475
de software en
\change_deleted -322385837 1492381476
de
\change_unchanged
 ejecución, como el 
\change_inserted -322385837 1492381493
tiempo de respuesta
\change_deleted -322385837 1492381962
uso de CPU, consumo de red
\change_unchanged
, precisión 
\change_deleted -322385837 1492381966
y desempeño
\change_unchanged
 de las respuestas, entre otros.
 Est
\change_deleted -322385837 1492381055
o
\change_inserted -322385837 1492381055
a
\change_unchanged
s 
\change_deleted -322385837 1492381057
indicadores
\change_inserted -322385837 1492381058
propiedades
\change_unchanged
 son valores continuos, motivo por el cual se 
\change_deleted -322385837 1492381580
utilizaron
\change_inserted -322385837 1492381583
entrenan y evaluan
\change_unchanged
 modelos de regresión
\change_inserted -322385837 1492382083
 para su predicción.
\change_deleted -322385837 1492381547
,
\change_unchanged
 
\change_inserted -322385837 1492381550
L
\change_deleted -322385837 1492381560
lo
\change_inserted -322385837 1492381560
a
\change_unchanged
s 
\change_inserted -322385837 1492381611
técnicas utilizadas
\change_deleted -322385837 1492381614
mismos
\change_unchanged
 se describ
\change_deleted -322385837 1492381631
irán en las subsecciones siguientes
\change_inserted -322385837 1492381640
en a continuación
\change_unchanged
.
 
\change_inserted -322385837 1492384319

\end_layout

\begin_layout Standard

\change_inserted -322385837 1492384320
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -322385837 1492384326
Dar menos detalle sobre las tecnicas
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Subsubsection
Regresión Lineal
\begin_inset CommandInset label
LatexCommand label
name "sub:Regresión-Lineal"

\end_inset


\end_layout

\begin_layout Standard
La regresión es la predicción de un valor desconocido a través del cálculo
 de una función matemática a partir de los valores conocidos.
 Si se considera esta función como una 
\change_inserted -322385837 1492382279
función lineal
\change_deleted -322385837 1492382277
línea recta
\change_unchanged
, la salida será la suma de cada valor conocido multiplicado por una constante
\change_inserted -322385837 1492382315
,
\change_unchanged
 l
\change_deleted -322385837 1492382319
a
\change_inserted -322385837 1492382319
o
\change_unchanged
 cual define 
\change_inserted -322385837 1492382322
un
\change_deleted -322385837 1492382323
l
\change_unchanged
a línea recta (plano en 3D o hiperplano en dimensiones mayores) que circundan
 los puntos
\change_inserted -322385837 1492382334
,
\change_unchanged
 como puede observarse en la 
\change_deleted -322385837 1492382337
f
\change_inserted -322385837 1492382337
F
\change_unchanged
igura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:regression-lineal"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/regression-lineal.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\change_deleted -322385837 1492382243
Algoritmo Linear regression
\change_inserted -322385837 1492382247
Regresiones lineales
\change_unchanged
 en dos y tres dimensiones..
 
\begin_inset CommandInset label
LatexCommand label
name "fig:regression-lineal"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para encontrar la recta
\change_inserted -322385837 1492382740
 (funcion lineal)
\change_unchanged
 que mejor se 
\change_deleted -322385837 1492382917
adapte
\change_inserted -322385837 1492382919

\begin_inset Quotes eld
\end_inset

ajusta
\begin_inset Quotes erd
\end_inset


\change_unchanged
 a los datos
\change_inserted -322385837 1492382928
,
\change_unchanged
 se intenta minimizar la distancia entre cada punto y dicha 
\change_deleted -322385837 1492382349
línea
\change_inserted -322385837 1492382355
recta.
\change_deleted -322385837 1492382356
,
\change_unchanged
 
\change_inserted -322385837 1492382358
E
\change_deleted -322385837 1492382357
e
\change_unchanged
sta distancia se mide a través de una línea auxiliar que atravies
\change_deleted -322385837 1492382415
e
\change_inserted -322385837 1492382415
a
\change_unchanged
 el punto y tope con la función
\change_deleted -322385837 1492382444
, por ejemplo mediante el Teorema de Pitágoras
\change_unchanged
.
 Luego, se intentará minimizar la función de error que 
\change_deleted -322385837 1492382466
mide
\change_inserted -322385837 1492382469
que se calcula como
\change_unchanged
 la suma de 
\change_deleted -322385837 1492382513
cada
\change_inserted -322385837 1492382514
las
\change_unchanged
 distancia
\change_inserted -322385837 1492382515
s.
 
\change_deleted -322385837 1492382521
, si se ignora las raíces y sólo
\change_inserted -322385837 1492382522
Si
\change_unchanged
 se minimiza la suma de los cuadrados de l
\change_deleted -322385837 1492382532
o
\change_inserted -322385837 1492382532
a
\change_unchanged
s 
\change_deleted -322385837 1492382535
errores
\change_inserted -322385837 1492382537
distancias
\change_unchanged
, se obtiene la minimización más común llamada optimización de mínimos cuadrados.
 
\end_layout

\begin_layout Standard
La minimización de est
\change_inserted -322385837 1492382899
e error, para ajustar la función lineal, puede realizarse con distintas
 técnicas de regresión lineal, como
\change_deleted -322385837 1492382849
a función da lugar a la implementación de diversas alternativas de la función
 lineal.
 En el presente trabajo se desarrollan dos variantes, la función denominada
\change_unchanged
 
\emph on
ridge-regression 
\emph default
y 
\change_deleted -322385837 1492382853
la función 
\change_unchanged

\emph on
gradiente estocástico descendiente
\emph default
.
 La primera aplica una penalización (
\emph on
ridge
\emph default
) a cada constante.
 La segunda, aplica un diferencial sobre la función obteniendo el gradiente
 el cual por definición, es la dirección en la que incrementa o disminuye
 en mayor medida.
 Ya que el propósito del aprendizaje es minimizar el error de predicción,
 se debe seguir la función en dirección del gradiente negativo en la cual
 la función disminuye.
 
\end_layout

\begin_layout Subsubsection
Red neuronal
\end_layout

\begin_layout Standard
Se presenta un modelo matemático sobre el comportamiento de una neurona,
 el modelo neuronal McCulloch - Pitts denominado así debido a sus creadores
 Warren McCulloch y Walter Pitts, ambos produjeron un ejemplo perfecto al
 modelar una célula nerviosa como 
\emph on
i
\emph default
) un conjunto de entradas valoradas (w
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

) que corresponde a las sinapsis, 
\emph on
ii
\emph default
) un sumador que une las señales entrantes (equivalente a la membrana de
 la célula que recolecta la carga eléctrica) y 
\emph on
iii
\emph default
) una función de activación (inicialmente una función umbral) que decide
 sobre la activación de la célula en base a las entradas actuales.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/McCulloch-Pitts.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modelo matemático neuronal McCulloch - Pitts.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:McCulloch-Pitts"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como puede observarse en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:McCulloch-Pitts"

\end_inset

, el modelo McCulloch - Pitts es un dispositivo límite binario, las entradas
 son multiplicadas por los pesos o fuerzas sinápticas y luego se suman sus
 valores, si la suma es mayor a un determinado umbral (produce salida 1)
 la célula se activa, de lo contrario (produce salida 0) se mantiene desactivada.
 Teniendo en cuenta que una red neuronal puede llevar a cabo cualquier cálculo
 que realiza una computadora normal, los pesos o valores de la fuerza sináptica
 deben ser elegidos correctamente, considerando en consecuencia, un método
 capaz de configurar dichos pesos.
 Observando la neurona McCulloch y Pitts, se puede notar fácilmente que
 las entradas son independientes al cerebro, por lo que sólo cambia el valor
 de los pesos y el umbral.
 Considerando que el aprendizaje sucede entre las neuronas y éstas están
 conectadas mutuamente, se debe tener en cuenta la manera en que en cambian
 los pesos y los umbrales de las neuronas para que la red pueda obtener
 la respuesta correcta más frecuentemente.
\end_layout

\begin_layout Standard
Teniendo en cuenta que una red neuronal puede llevar a cabo cualquier cálculo
 que realiza una computadora normal, los pesos o valores de la fuerza sináptica
 deben ser elegidos correctamente, considerando en consecuencia, un método
 capaz de configurar dichos pesos.
\end_layout

\begin_layout Standard
Observando la neurona McCulloch y Pitts, se puede notar fácilmente que las
 entradas son independientes al cerebro, por lo que sólo cambia el valor
 de los pesos y el umbral.
 Considerando que el aprendizaje sucede entre las neuronas y éstas están
 conectadas mutuamente, se debe tener en cuenta la manera en que en cambian
 los pesos y los umbrales de las neuronas para que la red pueda obtener
 la respuesta correcta más frecuentemente.
 
\end_layout

\begin_layout Subsubsection*
Red Neuronal Perceptron 
\end_layout

\begin_layout Standard
El perceptrón es una colección de neuronas McCulloch y Pitts con un conjunto
 de entradas y pesos que unen las neuronas con dichas entradas.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/perceptron-neural-network.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Red neuronal perceptron
\begin_inset CommandInset label
LatexCommand label
name "fig:perceptron-neural-network"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como puede observarse en el gráfico de la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perceptron-neural-network"

\end_inset

, las neuronas del Perceptrón son completamente independientes entre sí,
 el estado de una neurona no infiere sobre las demás, sólo comparten las
 entradas.
 Un punto a destacar es que el número de entradas y de neuronas no necesariament
e debe corresponderse, en general hay 
\emph on
m
\emph default
 entradas y 
\emph on
n
\emph default
 neuronas.
 
\end_layout

\begin_layout Standard
El mayor inconveniente es conocer con certeza los valores que deben tener
 los pesos para que las salidas sean las correctas, esta es la finalidad
 de la red neuronal, aprender si determinada neurona debe o no activarse
 de forma correcta.
 
\end_layout

\begin_layout Standard
Un proceso de análisis sobre los pesos podría arrojar que los pesos toman
 valores muy grandes en la activación de una neurona (cuando no debería
 hacerlo) o en caso contrario, valores muy pequeños, por lo que se podría
 computar una función de error como la diferencia entre la salida que produjo
 la neurona y la salida de la red.
 En el caso particular de entradas en cero, se modifica el valor de umbral
 añadiendo a la red Perceptron un parámetro extra denominado bias, los pesos
 de esta entrada son usualmente asignados al índice cero.
 
\end_layout

\begin_layout Subsubsection*
Red neuronal Perceptrón multicapa 
\end_layout

\begin_layout Standard
La esencia del aprendizaje de la red neuronal perceptrón está centrada en
 los valores de pesos, una buena práctica entonces, sería la incorporación
 de nuevos pesos.
 Como alternativa para ello podrían agregarse conecciones hacia atrás para
 conectar las neuronas de salida con las entradas nuevamente, o podrían
 agregarse nuevas neuronas creando redes mucho más complejas, como el caso
 reflejado en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perceptron-neural-network-multilayer"

\end_inset

 donde se representa un modelo perceptrón de tres capas con cinco entradas,
 tres salidas y tres neuronas en la capa oculta.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/Perceptron-multilayer.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Red perceptrón multicapa
\begin_inset CommandInset label
LatexCommand label
name "fig:perceptron-neural-network-multilayer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La nueva red, ahora, debe ser entrenada para que los pesos nuevos se adapten
 y generen las respuestas correctas (
\emph on
targets
\emph default
).
 Estas respuestas son conocidas y se puede computar la diferencia entre
 estas y las salidas pero se desconoce si el peso incorrecto pertenece a
 la primera capa o a la segunda y cuáles activaciones de las neuronas de
 la capa intermedia son correctas, razón por la cual esta capa se denomina
 capa oculta ya que es imposible examinar y corregir sus valores de forma
 inmediata.
 
\end_layout

\begin_layout Standard
El entrenamiento de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ac{MLP}
\end_layout

\end_inset

 consiste en dos partes, primero se obtienen las salidas con las entradas
 brindadas y los pesos actuales (
\emph on
forwards
\emph default
), y luego se actualizan los pesos considerando el error como la diferencia
 entre el valor obtenido y el real (propagación hacia atrás del error -
 
\emph on
backwards
\emph default
).
 
\end_layout

\begin_layout Standard
Por lo tanto, con la función de error y de activación, puede calcularse
 el diferencial para modificar los pesos en dirección del gradiente negativo,
 mejorando así la función de error.
 El objetivo es obtener los gradientes de esos errores y usarlos para decidir
 cuánto deben actualizarse dichos pesos en la red sobre la capa de salida
 y, luego de actualizarla, se opera hacia atrás (
\emph on
backwards
\emph default
) a través de la red hasta llegar a la entrada nuevamente.
 Sólo existen dos problemas, para las neuronas de salida se desconocen las
 entradas que le corresponden y para las neuronas escondidas, se desconocen
 las salidas esperadas (
\emph on
targets
\emph default
) y en caso de existir más capas incluso podrían no conocerse las entradas.
 Para solucionar estas cuestiones se aplica la regla de la cadena la cual
 afirma que para conocer la forma en que varía el error en base a la variación
 de los pesos, se debe analizar la variación del error en función de las
 entradas de los pesos y multiplicarlo por el valor de la variación de los
 pesos según la variación de entradas.
 
\end_layout

\begin_layout Standard
Esta forma de resolución es muy útil ya que permite conocer todas las derivadas
 que se necesitan.
 Puede escribirse la función de activación de los nodos de salida en términos
 de los nodos ocultos y de los pesos de salida para luego enviarlo hacia
 las capas ocultas de la red (hacia atrás) para decidir cuáles eran los
 salidas esperadas para esas neuronas.
\end_layout

\begin_layout Subsubsection
K-means clusterer
\end_layout

\begin_layout Standard
El algoritmo K - means aplica clustering sobre los datos de entrenamiento
 y recibe un parámetro 
\emph on
K
\emph default
 para dividir estos datos en 
\emph on
K
\emph default
 categorías.
 El algoritmo intenta localizar k centros en el espacio de entrada de modo
 tal que estos centros estén, como su nombre lo indica, en el centro de
 una categoría (
\emph on
cluster
\emph default
).
 La dificultad se presenta ya que al desconocer la categorización de estos
 grupos, resulta aún más difícil determinar la localización de cada centro.
 
\end_layout

\begin_layout Standard
Los algoritmos de aprendizaje generalmente se basan en minimizar alguna
 clase de error, en consecuencia la primera acción que se realiza es definir
 un criterio que lo describa teniendo en cuenta: 
\emph on
i
\emph default
) una medida de la distancia entre puntos, definir una medida para cuantificar
 estas distancias, por lo general se usa la distancia euclídea y 
\emph on
ii
\emph default
) determinar el punto central de un conjunto de puntos (
\emph on
mean average
\emph default
) considerando el espacio euclídeo ya que en espacios curvos es otra la
 interpretación.
 Teniendo en cuenta estos conceptos, el algoritmo K - means calcula el punto
 medio (centro) de cada cluster (µ
\begin_inset script subscript

\begin_layout Plain Layout
c
\end_layout

\end_inset

(i)).
 lo que resulta equivalente a minimizar la distancia euclídea de cada punto
 del cluster al centro del mismo.
 
\end_layout

\begin_layout Standard
El objetivo de determinar estos centros, en principio, a causa de incertidumbre
 total se posicionan los centros de forma aleatoria en el espacio de entrada.
 Una vez distinguidos los clusters, se determinar los puntos que pertenecen
 al mismo a través del cálculo de la distancia entre el punto y todos los
 centros localizados, asignándose entonces, al cluster cuyo centro sea el
 más cercano.
 Finalmente, para cada centro se actualiza su ubicación utilizando la media
 antes definida.
 Estos pasos se realizan de forma incremental hasta que los centros dejar
 de modificar su ubicación.
 
\end_layout

\begin_layout Standard
Ya que este algoritmo sin duda es un método de clasificación y no de regresión,
 se considera importante resaltar la adaptación del mismo para utilizarlo
 con este fin.
 Así, una vez realizada la clasificación del punto que se quiere predecir,
 se realizará la predicción calculando el promedio de los valores del atributo
 a predecir de los otros puntos que están en el cluster.
 
\end_layout

\begin_layout Subsubsection
Maquina de vector de soporte
\end_layout

\begin_layout Standard
Al tratar con problemas de clasificación existen varios clasificadores lineales
 que ofrecen respuestas correctas pero diferentes, como se expone en la
 figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:lineals-classifiers"

\end_inset

.
 Si bien las soluciones laterales son acertadas, las líneas divisorias son
 muy próximas a algunos puntos del conjunto de datos de entrenamiento dando
 paso a una posible imprecisión futura en la predicción, situación que no
 se observa en el ejemplo central de la figura.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/lineals-classifiers.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparación de tres clasificadores lineales distintos.
\begin_inset CommandInset label
LatexCommand label
name "fig:lineals-classifiers"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Analíticamente, se toma la distancia existente entre la línea y el primer
 punto interceptado (en dirección perpendicular), si se ubica una ‘zona
 desierta’ alrededor de la línea, ningún punto ubicado en dicha zona puede
 ser clasificado ya que se encuentra demasiado cerca de la línea.
 Esta región conforma un cilindro simétrico alrededor de la función en 3D
 y un hiper - cilindro en dimensiones mayores.
 El radio máximo que puede tener esta región es llamado margen, señalado
 como M y los puntos de cada clase más cercanos a la línea de clasificación
 se denominan vectores de soporte.
 Si se considera el mejor clasificador como aquel que atraviesa la zona
 desierta, se debe tener en cuenta que el margen debe ser lo más grande
 posible y que si los vectores de soporte son los puntos más importantes
 de los datos, luego del entrenamiento pueden descartarse los puntos que
 no pertenecen al vector y utilizarlos para clasificar, lo cual conlleva
 una gran eficiencia en el almacenamiento de datos.
 El algoritmo puede encontrar varios hiperplanos de separación posibles
 y detectar aquel que sea más óptimo.
 En la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SVM-metology"

\end_inset

 se reflejan estas dos situaciones y se expone, en el gráfico derecho las
 notaciones matemáticas formales del algoritmo.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/SVM-metology.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Metodología de operación del algoritmo SVM
\begin_inset CommandInset label
LatexCommand label
name "fig:SVM-metology"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A través de la función 
\emph on
g(x) = w
\begin_inset script superscript

\begin_layout Plain Layout
t
\end_layout

\end_inset

x + b
\emph default
 se definen los dos hiperplanos (clasificador).
 Para obtener el punto más cercano desde la línea de clasificación considerando
 la clase 2 (ver figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SVM-metology"

\end_inset

) se recorre en dirección perpendicular partiendo del límite de la clase
 1 hasta llegar al límite de la clase 2, el primer punto interceptado se
 denomina x.
 Para obtener un clasificador de buena calidad, se pueden definir un conjunto
 de restricciones que indiquen la manera en que el clasificador podría obtener
 la respuesta correcta.
 Por ejemplo, si en lugar de tomar las dos clases como 
\emph on
g(x) = 1
\emph default
 y 
\emph on
g(x) = 0
\emph default
, se podrían igualar a los valores 1 y -1 y así obtener una respuesta correcta
 diferente.
 Estos tipos de problemas pueden ser resueltos de forma directa y eficiente
 (por ejemplo, en tiempo polinomial), gracias a que existen algoritmos de
 programación cuadrática que brindan soluciones efectivas.
\end_layout

\begin_layout Standard
Todas las consideraciones expuestas hasta el momento se realizaron tras
 la asunción de que los datos podían ser divididos con funciones lineales,
 pero no siempre es posible, en este caso la solución es introducir variables.
 Estas variables indican que, al comparar clasificadores, si uno clasifica
 un punto en un lado incorrecto y el otro lo ubica mucho más lejos (también
 en un lado incorrecto) el primero es mejor que el segundo, el error no
 fue tan extremo como en el segundo y esta información debe ser incluida
 en los criterios de minimización modificando las restricciones, incluyendo
 un parámetro 
\emph on
C
\emph default
.
 
\emph on
C
\emph default
 es el parámetro que indica el trade off que existe entre ambos parámetros:
 cuanto más pequeño sea el valor de C más importancia toma el margen sobre
 algunos errores, cuanto más grande se vuelve C ocurre lo contrario.
 Esto transforma el problema en un clasificador de margen suave ya que se
 permiten algunos errores.
 La forma de evitarlos es modificando las características para que los datos
 sean linealmente separables, los datos no pueden inventarse de modo que
 las características deben ser derivadas a partir de las existentes.
 Para ello se describe una nueva función llamada kernel denominada 
\emph on
φ(x)
\emph default
 que se aplica sobre las diferentes variables de entrada, su función principal
 es transformar los datos para obtener un espacio de dimensión mayor.
 Como función kernel puede utilizarse cualquier función simétrica que está
 definida positivamente (positividad de la integral de funciones arbitrarias).
 Incluso, la conjunción de dos funciones kernel significa una nueva función
 kernel.
 Elegir la función kernel más conveniente es un problema complejo.
 A pesar que existen algunas teorías, el proceso más común es la experimentación
 con distintos valores para determinar la función más adecuada utilizando
 el conjunto de validación.
 El algoritmo que aplica vectores de soporte se rige bajo todos los conceptos
 expresados a lo largo del apartado para realizar clasificación, pero también
 aplica para realizar regresión sobre los datos, variante que fue utilizada
 en el presente trabajo.
 La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SVM-regression"

\end_inset

 muestra un ejemplo de la aplicación del algoritmo SVM para regresión.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/SVM-regression.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Algoritmo SVM para regresión con función kernel de base radial.
\begin_inset CommandInset label
LatexCommand label
name "fig:SVM-regression"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Evaluación de modelos
\end_layout

\begin_layout Standard

\change_inserted -322385837 1492383614
Una vez entrenado un modelo de predicción con una técnica, 
\change_deleted -322385837 1492383500
L
\change_inserted -322385837 1492383500
l
\change_unchanged
a evaluación del 
\change_deleted -322385837 1492383524
rendimiento de un 
\change_unchanged
modelo es 
\change_deleted -322385837 1492383535
una de las fases principales en el proceso de ciencia de datos.
 Indica
\change_inserted -322385837 1492383552
importante para medir
\change_unchanged
 el nivel de acierto de las predicciones
\change_deleted -322385837 1492383567
 del conjunto de datos mediante un modelo entrenado
\change_unchanged
.
 
\change_inserted -322385837 1492385326
Esta evaluación consiste en probar el modelo con un conjunto de datos de
 prueba y medir el error u otras métricas sobre los resultados.
 Estas métricas de evaluación permite comparar el desempeño de modelos entrenado
s con diferentes tecnicas.
 
\change_unchanged

\end_layout

\begin_layout Standard
Existen 
\change_deleted -322385837 1492384806
dos
\change_inserted -322385837 1492385123
distintas
\change_unchanged
 formas para 
\change_inserted -322385837 1492385123
llevar a cabo esta 
\change_unchanged
evalua
\change_inserted -322385837 1492385612
ción.
 La mas simple consiste en usar como datos de prueba el mismo conjunto de
 datos utilizado para el entrenamiento de los modelos.
 Otro método consiste en separar los datos del problema entre datos de entrenami
ento y datos de prueba.
 
\change_deleted -322385837 1492385383
r: evaluar el modelo y
\change_inserted -322385837 1492385648
 Por ultima, tambien se puede
\change_unchanged
 validar el modelo de forma cruzada.
 
\change_deleted -322385837 1492385405
Estos métodos permiten conocer el rendimiento del modelo como un número
 de métricas que se usan habitualmente en estadísticas y aprendizaje automático.
 La evaluación y la validación cruzada son métodos estándares para medir
 el rendimiento de un modelo.
 Ambos generan métricas de evaluación que sirven para inspeccionar y comparar
 con las de otros modelos.
 
\change_unchanged

\end_layout

\begin_layout Standard

\change_inserted -322385837 1492385777
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -322385837 1492385793
Revisar este parrafo.
 Que explique brevemente en que consiste la validacion cruzada
\end_layout

\end_inset


\change_unchanged
La evaluación se basa en los valores predictivos junto con las etiquetas
 o valores verdaderos.
 De forma alternativa, es posible usar la validación cruzada para realizar
 automáticamente varias operaciones de entrenamiento, puntuación y evaluación
 (10 subconjuntos) en distintos subconjuntos de los datos de entrada.
 Los datos de entrada se dividen en 10 partes, donde una se reserva para
 las pruebas y las otras 9 para el entrenamiento.
 Este proceso se repite 10 veces y se calcula el promedio de las métricas
 de evaluación.
 Esto ayuda a determinar el nivel al que un modelo se podría generalizar
 para nuevos conjuntos de datos.
 
\end_layout

\begin_layout Standard
El presente trabajo 
\change_deleted -322385837 1492384059
implementa
\change_inserted -322385837 1492384060
contempla
\change_unchanged
 las siguientes métricas de evaluación para los modelos de regresión: 
\change_inserted -322385837 1492384234

\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -322385837 1492613404
Poner solo 1 o 2 metricas como ejemplo, y explicarlas un poquito.
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Itemize
CC (Coeficiente de correlación de Pearson)
\end_layout

\begin_layout Itemize
MAE (Mean Absolute Error) 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[ 
\backslash
frac{1}{N}
\backslash
sum_{i=1}^{N}{f_i-y_i}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
RMSE (Root Mean Absolute Error)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[ 
\backslash
sqrt{
\backslash
frac{1}{N}
\backslash
sum_{i=1}^{N}{f_i-y_i}^2}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
RAE (Relative Absolute Error)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[ 
\backslash
frac{
\backslash
sum_{i=1}^{N}{|f_i-y_i}|}{
\backslash
sum_{i=1}^{N}{|
\backslash
overline{f_i}-y_i}|}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
RRSE (Root Relative Squared Error)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[ 
\backslash
sqrt{
\backslash
frac{
\backslash
sum_{i=1}^{N}{(f_i-y_i)^2}}{
\backslash
sum_{i=1}^{N}{(
\backslash
overline{f_i}-y_i)^2}}}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
COMB
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[ (1-CC)+RRSE+RAE
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
SIMPLE ERROR
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[ 
\backslash
sum_{i=1}^{N}{(f_i-y_i)^2}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El término 
\emph on
error 
\emph default
representa la diferencia entre el valor predicho y el valor verdadero.
 Normalmente, se calcula el valor absoluto o el cuadrado de esta diferencia
 para capturar la magnitud total de errores en todas las instancias, dado
 que la diferencia entre el valor verdadero y el predicho puede ser negativa
 en algunos casos.
 Las métricas de error miden el rendimiento de predicción de un modelo de
 regresión en cuanto a la desviación media de sus predicciones a partir
 de los valores reales.
 Los valores de error más bajos implican que el modelo es más preciso a
 la hora de realizar predicciones.
 Una métrica de error general de 0 significa que el modelo se ajusta a los
 datos perfectamente.
\end_layout

\begin_layout Subsection
Ajuste del modelo: Overfitting y Underfitting
\begin_inset CommandInset label
LatexCommand label
name "sub:Ajuste-del-modelo:"

\end_inset


\end_layout

\begin_layout Standard
Cuando 
\change_deleted -322385837 1492385886
un clasificador es entrenado 
\change_unchanged
se genera
\change_inserted -322385837 1492385892
 (o entrena)
\change_unchanged
 un modelo de predicción
\change_inserted -322385837 1492385903
, 
\change_deleted -322385837 1492385904
 cuya
\change_inserted -322385837 1492385905
su
\change_unchanged
 
\change_deleted -322385837 1492386096
calidad
\change_inserted -322385837 1492386097
desempeño
\change_unchanged
 es incierta hasta su 
\change_inserted -322385837 1492385866
evaluación o 
\change_unchanged
aplicación.
 En algunas ocasiones, la calidad del modelo es pobre generando respuestas
 imprecisas, de modo tal que se le deben aplicar acciones correctivas comprendie
ndo cómo se comporta y ajusta el modelo.
 
\end_layout

\begin_layout Standard
Los modelos pueden presentar dos 
\change_deleted -322385837 1492386016
efectos
\change_inserted -322385837 1492386016
problemas
\change_unchanged
 indeseables
\change_inserted -322385837 1492386048
: 
\emph on
overfitting
\emph default
 y 
\emph on
underfitting
\change_deleted -322385837 1492385982

\emph default
 
\change_unchanged
.
 El 
\change_deleted -322385837 1492386058
efecto de
\change_unchanged
 
\emph on
overfitting 
\emph default
describe una función que se ajusta estrechamente a los datos de entrenamiento
\change_inserted -322385837 1492386077
.
 
\change_deleted -322385837 1492386078
, e
\change_inserted -322385837 1492386078
E
\change_unchanged
l modelo aprendió los detalles y el ruido en los datos impactando negativamente
 en el desempeño del modelo
\change_deleted -322385837 1492386144
, ha sido incapaz de generalizar
\change_unchanged
.
 Este efecto es causado porque el ruido o las fluctuaciones aleatorias en
 los datos de entrada fueron usados para el aprendizaje.
 Los problemas de overfitting son más probables en modelos no parametrizados
 y no lineales, los cuales tienen mayor flexibilidad al aprender funciones.
 Por lo tanto, muchos algoritmos de aprendizaje de máquina no parametrizados
 incluyen parámetros o técnicas para limitar y restringir los detalles que
 el modelo aprende.
 Por ejemplo, los árboles de decisión son algoritmos de aprendizaje no parametri
zados muy flexibles y pueden estar sujetos al efecto de overfitting, en
 cuyo caso se procede a podar el árbol una vez que el aprendizaje sea suficiente
, eliminando así algunos detalles innecesarios.

\change_deleted -322385837 1492386198
 Para solucionar este efecto se debe modificar el grado del polinomio de
 la función utilizada por el modelo.
 
\change_unchanged

\end_layout

\begin_layout Standard
Por otro lado, los modelos pueden presentar 
\change_deleted -322385837 1492386203
efectos
\change_inserted -322385837 1492386204
problemas
\change_unchanged
 de 
\emph on
underfitting
\emph default
, 
\change_deleted -322385837 1492386287
funciones que
\change_inserted -322385837 1492386288
cuando
\change_unchanged
 no interpretan 
\change_deleted -322385837 1492386299
o definen
\change_inserted -322385837 1492386299
bien
\change_unchanged
 los datos de entrenamiento, por lo que son incapaces de generalizar correctamen
te nuevos datos
\change_inserted -322385837 1492386307
.
 
\change_deleted -322385837 1492386308
, e
\change_inserted -322385837 1492386308
E
\change_unchanged
ste efecto es causado porque la función o modelo elegido no es el indicado
 para representar el comportamiento de los datos
\change_inserted -322385837 1492386322
.
 
\change_deleted -322385837 1492386322
, e
\change_inserted -322385837 1492386323
E
\change_unchanged
l efecto underfitting se caracteriza por sobre generalizar los datos.
 La incorporación de nuevos datos al conjunto de entrenamiento podría solucionar
 o apaciguar este efecto.
 
\end_layout

\begin_layout Standard
El modelo deseado, sin dudas, sería aquel que se encuentre en un punto de
 equilibrio entre 
\change_deleted -322385837 1492386617
modelos con underfitting y overfitting
\change_inserted -322385837 1492386623
un problema y otro
\change_unchanged
, aunque est
\change_inserted -322385837 1492386436
e equilibrio
\change_deleted -322385837 1492386432
a eficiencia
\change_unchanged
 es muy difícil de alcanzar en la práctica.
 La 
\change_deleted -322385837 1492386523
f
\change_inserted -322385837 1492386523
F
\change_unchanged
igura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:under-overfitting"

\end_inset

 
\change_deleted -322385837 1492386494
refleja
\change_inserted -322385837 1492386665
presenta tres modelos de regresión para un mismo grupo de datos que permiten
 interpretar gráficamente los problemas de underfitting y overfitting.

\change_deleted -322385837 1492386604
 el contraste entre los tres posibles estados de un modelo.
 
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/usuario/Tesisworkspace/Tesis_Standalone/tesis/images/under-overfitting.png
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Contraste entre distintos efectos del modelo sobre los datos de entrenamiento.
\begin_inset CommandInset label
LatexCommand label
name "fig:under-overfitting"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted -322385837 1492386815
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -322385837 1492386825
No se entiende muy bien esto :S
\change_unchanged

\end_layout

\end_inset


\change_unchanged
El análisis de ambos efectos, se realiza gráficamente describiendo la performanc
e del algoritmo y la forma en que va aprendiendo a través del tiempo.
 Al graficar la habilidad basada en los datos de entrenamiento y en los
 datos de validación (testing), puede notarse que el error basado en en
 el último gráfico de la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:under-overfitting"

\end_inset

 comienza a disminuir por efectos de overfitting ya que comienza a aprender
 datos irrelevantes y ruidos del conjunto.
 En cuanto al gráfico central (modelo esperado), se puede notar que el error
 aumenta mientras el modelo aprender a generalizar.
 
\end_layout

\begin_layout Standard
  
\end_layout

\end_body
\end_document
